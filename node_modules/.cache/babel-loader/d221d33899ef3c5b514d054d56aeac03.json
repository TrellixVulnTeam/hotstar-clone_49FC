{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toExtensionVersionName = exports.toExtensionName = exports.toExtensionVersionRef = exports.toExtensionRef = exports.parse = void 0;\n\nconst semver = require(\"semver\");\n\nconst error_1 = require(\"../error\");\n\nconst refRegex = new RegExp(/^([^/@\\n]+)\\/{1}([^/@\\n]+)(@{1}([^\\n]+)|)$/);\n\nfunction parse(refOrName) {\n  const ret = parseRef(refOrName) || parseName(refOrName);\n\n  if (!ret || !ret.publisherId || !ret.extensionId) {\n    throw new error_1.FirebaseError(`Unable to parse ${refOrName} as an extension ref`);\n  }\n\n  if (ret.version && !semver.valid(ret.version) && !semver.validRange(ret.version) && ret.version !== \"latest\") {\n    throw new error_1.FirebaseError(`Extension reference ${ret} contains an invalid version ${ret.version}.`);\n  }\n\n  return ret;\n}\n\nexports.parse = parse;\n\nfunction parseRef(ref) {\n  const parts = refRegex.exec(ref);\n\n  if (parts && (parts.length == 5 || parts.length == 7)) {\n    const publisherId = parts[1];\n    const extensionId = parts[2];\n    const version = parts[4];\n    return {\n      publisherId,\n      extensionId,\n      version\n    };\n  }\n}\n\nfunction parseName(name) {\n  const parts = name.split(\"/\");\n  return {\n    publisherId: parts[1],\n    extensionId: parts[3],\n    version: parts[5]\n  };\n}\n\nfunction toExtensionRef(ref) {\n  return `${ref.publisherId}/${ref.extensionId}`;\n}\n\nexports.toExtensionRef = toExtensionRef;\n\nfunction toExtensionVersionRef(ref) {\n  if (!ref.version) {\n    throw new error_1.FirebaseError(`Ref does not have a version`);\n  }\n\n  return `${ref.publisherId}/${ref.extensionId}@${ref.version}`;\n}\n\nexports.toExtensionVersionRef = toExtensionVersionRef;\n\nfunction toExtensionName(ref) {\n  return `publishers/${ref.publisherId}/extensions/${ref.extensionId}`;\n}\n\nexports.toExtensionName = toExtensionName;\n\nfunction toExtensionVersionName(ref) {\n  if (!ref.version) {\n    throw new error_1.FirebaseError(`Ref does not have a version`);\n  }\n\n  return `publishers/${ref.publisherId}/extensions/${ref.extensionId}/versions/${ref.version}`;\n}\n\nexports.toExtensionVersionName = toExtensionVersionName;","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/extensions/refs.js"],"names":["Object","defineProperty","exports","value","toExtensionVersionName","toExtensionName","toExtensionVersionRef","toExtensionRef","parse","semver","require","error_1","refRegex","RegExp","refOrName","ret","parseRef","parseName","publisherId","extensionId","FirebaseError","version","valid","validRange","ref","parts","exec","length","name","split"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toExtensionVersionName = exports.toExtensionName = exports.toExtensionVersionRef = exports.toExtensionRef = exports.parse = void 0;\nconst semver = require(\"semver\");\nconst error_1 = require(\"../error\");\nconst refRegex = new RegExp(/^([^/@\\n]+)\\/{1}([^/@\\n]+)(@{1}([^\\n]+)|)$/);\nfunction parse(refOrName) {\n    const ret = parseRef(refOrName) || parseName(refOrName);\n    if (!ret || !ret.publisherId || !ret.extensionId) {\n        throw new error_1.FirebaseError(`Unable to parse ${refOrName} as an extension ref`);\n    }\n    if (ret.version &&\n        !semver.valid(ret.version) &&\n        !semver.validRange(ret.version) &&\n        ret.version !== \"latest\") {\n        throw new error_1.FirebaseError(`Extension reference ${ret} contains an invalid version ${ret.version}.`);\n    }\n    return ret;\n}\nexports.parse = parse;\nfunction parseRef(ref) {\n    const parts = refRegex.exec(ref);\n    if (parts && (parts.length == 5 || parts.length == 7)) {\n        const publisherId = parts[1];\n        const extensionId = parts[2];\n        const version = parts[4];\n        return { publisherId, extensionId, version };\n    }\n}\nfunction parseName(name) {\n    const parts = name.split(\"/\");\n    return {\n        publisherId: parts[1],\n        extensionId: parts[3],\n        version: parts[5],\n    };\n}\nfunction toExtensionRef(ref) {\n    return `${ref.publisherId}/${ref.extensionId}`;\n}\nexports.toExtensionRef = toExtensionRef;\nfunction toExtensionVersionRef(ref) {\n    if (!ref.version) {\n        throw new error_1.FirebaseError(`Ref does not have a version`);\n    }\n    return `${ref.publisherId}/${ref.extensionId}@${ref.version}`;\n}\nexports.toExtensionVersionRef = toExtensionVersionRef;\nfunction toExtensionName(ref) {\n    return `publishers/${ref.publisherId}/extensions/${ref.extensionId}`;\n}\nexports.toExtensionName = toExtensionName;\nfunction toExtensionVersionName(ref) {\n    if (!ref.version) {\n        throw new error_1.FirebaseError(`Ref does not have a version`);\n    }\n    return `publishers/${ref.publisherId}/extensions/${ref.extensionId}/versions/${ref.version}`;\n}\nexports.toExtensionVersionName = toExtensionVersionName;\n"]},"metadata":{},"sourceType":"script"}