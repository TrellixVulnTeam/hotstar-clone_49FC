{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addResourcesToBackend = exports.discoverBackend = exports.useStrategy = exports.GCS_EVENTS = void 0;\n\nconst path = require(\"path\");\n\nconst _ = require(\"lodash\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst error_1 = require(\"../../../../error\");\n\nconst logger_1 = require(\"../../../../logger\");\n\nconst backend = require(\"../../backend\");\n\nconst api = require(\"../../../../api\");\n\nconst proto = require(\"../../../../gcp/proto\");\n\nconst TRIGGER_PARSER = path.resolve(__dirname, \"./triggerParser.js\");\nexports.GCS_EVENTS = new Set([\"google.cloud.storage.object.v1.finalized\", \"google.cloud.storage.object.v1.archived\", \"google.cloud.storage.object.v1.deleted\", \"google.cloud.storage.object.v1.metadataUpdated\"]);\n\nfunction removeInspectOptions(options) {\n  return options.filter(opt => !opt.startsWith(\"--inspect\"));\n}\n\nfunction parseTriggers(projectId, sourceDir, configValues, envs) {\n  return new Promise((resolve, reject) => {\n    const env = Object.assign({}, envs);\n    env.GCLOUD_PROJECT = projectId;\n\n    if (!_.isEmpty(configValues)) {\n      env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);\n    }\n\n    const execArgv = removeInspectOptions(process.execArgv);\n\n    if (env.NODE_OPTIONS) {\n      env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(\" \")).join(\" \");\n    }\n\n    const parser = child_process_1.fork(TRIGGER_PARSER, [sourceDir], {\n      silent: true,\n      env: env,\n      execArgv: execArgv\n    });\n    parser.on(\"message\", message => {\n      if (message.triggers) {\n        resolve(message.triggers);\n      } else if (message.error) {\n        reject(new error_1.FirebaseError(message.error, {\n          exit: 1\n        }));\n      }\n    });\n    parser.on(\"exit\", code => {\n      if (code !== 0) {\n        reject(new error_1.FirebaseError(\"There was an unknown problem while trying to parse function triggers.\", {\n          exit: 2\n        }));\n      }\n    });\n  });\n}\n\nfunction useStrategy(context) {\n  return Promise.resolve(true);\n}\n\nexports.useStrategy = useStrategy;\n\nasync function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {\n  const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);\n  const want = Object.assign(Object.assign({}, backend.empty()), {\n    environmentVariables: envs\n  });\n\n  for (const annotation of triggerAnnotations) {\n    addResourcesToBackend(projectId, runtime, annotation, want);\n  }\n\n  return want;\n}\n\nexports.discoverBackend = discoverBackend;\n\nfunction addResourcesToBackend(projectId, runtime, annotation, want) {\n  var _a;\n\n  Object.freeze(annotation);\n\n  for (const region of annotation.regions || [api.functionsDefaultRegion]) {\n    let triggered;\n\n    if (!!annotation.httpsTrigger == !!annotation.eventTrigger) {\n      throw new error_1.FirebaseError(\"Unexpected annotation generated by the Firebase Functions SDK. This should never happen.\");\n    }\n\n    if (annotation.httpsTrigger) {\n      const trigger = {};\n\n      if (annotation.failurePolicy) {\n        logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);\n      }\n\n      proto.copyIfPresent(trigger, annotation.httpsTrigger, \"invoker\");\n      triggered = {\n        httpsTrigger: trigger\n      };\n    } else if (annotation.schedule) {\n      want.requiredAPIs[\"pubsub\"] = \"pubsub.googleapis.com\";\n      want.requiredAPIs[\"scheduler\"] = \"cloudscheduler.googleapis.com\";\n      triggered = {\n        scheduleTrigger: annotation.schedule\n      };\n    } else {\n      triggered = {\n        eventTrigger: {\n          eventType: annotation.eventTrigger.eventType,\n          eventFilters: {\n            resource: annotation.eventTrigger.resource\n          },\n          retry: !!annotation.failurePolicy\n        }\n      };\n\n      if (exports.GCS_EVENTS.has(((_a = annotation.eventTrigger) === null || _a === void 0 ? void 0 : _a.eventType) || \"\")) {\n        triggered.eventTrigger.eventFilters = {\n          bucket: annotation.eventTrigger.resource\n        };\n      }\n    }\n\n    const endpoint = Object.assign({\n      platform: annotation.platform || \"gcfv1\",\n      id: annotation.name,\n      region: region,\n      project: projectId,\n      entryPoint: annotation.entryPoint,\n      runtime: runtime\n    }, triggered);\n\n    if (annotation.vpcConnector) {\n      let maybeId = annotation.vpcConnector;\n\n      if (!maybeId.includes(\"/\")) {\n        maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;\n      }\n\n      endpoint.vpcConnector = maybeId;\n    }\n\n    proto.copyIfPresent(endpoint, annotation, \"concurrency\", \"serviceAccountEmail\", \"labels\", \"vpcConnectorEgressSettings\", \"ingressSettings\", \"timeout\", \"maxInstances\", \"minInstances\", \"availableMemoryMb\");\n    want.endpoints[region] = want.endpoints[region] || {};\n    want.endpoints[region][endpoint.id] = endpoint;\n  }\n}\n\nexports.addResourcesToBackend = addResourcesToBackend;","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/deploy/functions/runtimes/node/parseTriggers.js"],"names":["Object","defineProperty","exports","value","addResourcesToBackend","discoverBackend","useStrategy","GCS_EVENTS","path","require","_","child_process_1","error_1","logger_1","backend","api","proto","TRIGGER_PARSER","resolve","__dirname","Set","removeInspectOptions","options","filter","opt","startsWith","parseTriggers","projectId","sourceDir","configValues","envs","Promise","reject","env","assign","GCLOUD_PROJECT","isEmpty","CLOUD_RUNTIME_CONFIG","JSON","stringify","execArgv","process","NODE_OPTIONS","split","join","parser","fork","silent","on","message","triggers","error","FirebaseError","exit","code","context","runtime","triggerAnnotations","want","empty","environmentVariables","annotation","_a","freeze","region","regions","functionsDefaultRegion","triggered","httpsTrigger","eventTrigger","trigger","failurePolicy","logger","warn","name","copyIfPresent","schedule","requiredAPIs","scheduleTrigger","eventType","eventFilters","resource","retry","has","bucket","endpoint","platform","id","project","entryPoint","vpcConnector","maybeId","includes","endpoints"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,qBAAR,GAAgCF,OAAO,CAACG,eAAR,GAA0BH,OAAO,CAACI,WAAR,GAAsBJ,OAAO,CAACK,UAAR,GAAqB,KAAK,CAA1G;;AACA,MAAMC,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,CAAC,GAAGD,OAAO,CAAC,QAAD,CAAjB;;AACA,MAAME,eAAe,GAAGF,OAAO,CAAC,eAAD,CAA/B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,mBAAD,CAAvB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,eAAD,CAAvB;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMO,KAAK,GAAGP,OAAO,CAAC,uBAAD,CAArB;;AACA,MAAMQ,cAAc,GAAGT,IAAI,CAACU,OAAL,CAAaC,SAAb,EAAwB,oBAAxB,CAAvB;AACAjB,OAAO,CAACK,UAAR,GAAqB,IAAIa,GAAJ,CAAQ,CACzB,0CADyB,EAEzB,yCAFyB,EAGzB,wCAHyB,EAIzB,gDAJyB,CAAR,CAArB;;AAMA,SAASC,oBAAT,CAA8BC,OAA9B,EAAuC;AACnC,SAAOA,OAAO,CAACC,MAAR,CAAgBC,GAAD,IAAS,CAACA,GAAG,CAACC,UAAJ,CAAe,WAAf,CAAzB,CAAP;AACH;;AACD,SAASC,aAAT,CAAuBC,SAAvB,EAAkCC,SAAlC,EAA6CC,YAA7C,EAA2DC,IAA3D,EAAiE;AAC7D,SAAO,IAAIC,OAAJ,CAAY,CAACb,OAAD,EAAUc,MAAV,KAAqB;AACpC,UAAMC,GAAG,GAAGjC,MAAM,CAACkC,MAAP,CAAc,EAAd,EAAkBJ,IAAlB,CAAZ;AACAG,IAAAA,GAAG,CAACE,cAAJ,GAAqBR,SAArB;;AACA,QAAI,CAACjB,CAAC,CAAC0B,OAAF,CAAUP,YAAV,CAAL,EAA8B;AAC1BI,MAAAA,GAAG,CAACI,oBAAJ,GAA2BC,IAAI,CAACC,SAAL,CAAeV,YAAf,CAA3B;AACH;;AACD,UAAMW,QAAQ,GAAGnB,oBAAoB,CAACoB,OAAO,CAACD,QAAT,CAArC;;AACA,QAAIP,GAAG,CAACS,YAAR,EAAsB;AAClBT,MAAAA,GAAG,CAACS,YAAJ,GAAmBrB,oBAAoB,CAACY,GAAG,CAACS,YAAJ,CAAiBC,KAAjB,CAAuB,GAAvB,CAAD,CAApB,CAAkDC,IAAlD,CAAuD,GAAvD,CAAnB;AACH;;AACD,UAAMC,MAAM,GAAGlC,eAAe,CAACmC,IAAhB,CAAqB7B,cAArB,EAAqC,CAACW,SAAD,CAArC,EAAkD;AAC7DmB,MAAAA,MAAM,EAAE,IADqD;AAE7Dd,MAAAA,GAAG,EAAEA,GAFwD;AAG7DO,MAAAA,QAAQ,EAAEA;AAHmD,KAAlD,CAAf;AAKAK,IAAAA,MAAM,CAACG,EAAP,CAAU,SAAV,EAAsBC,OAAD,IAAa;AAC9B,UAAIA,OAAO,CAACC,QAAZ,EAAsB;AAClBhC,QAAAA,OAAO,CAAC+B,OAAO,CAACC,QAAT,CAAP;AACH,OAFD,MAGK,IAAID,OAAO,CAACE,KAAZ,EAAmB;AACpBnB,QAAAA,MAAM,CAAC,IAAIpB,OAAO,CAACwC,aAAZ,CAA0BH,OAAO,CAACE,KAAlC,EAAyC;AAAEE,UAAAA,IAAI,EAAE;AAAR,SAAzC,CAAD,CAAN;AACH;AACJ,KAPD;AAQAR,IAAAA,MAAM,CAACG,EAAP,CAAU,MAAV,EAAmBM,IAAD,IAAU;AACxB,UAAIA,IAAI,KAAK,CAAb,EAAgB;AACZtB,QAAAA,MAAM,CAAC,IAAIpB,OAAO,CAACwC,aAAZ,CAA0B,uEAA1B,EAAmG;AAAEC,UAAAA,IAAI,EAAE;AAAR,SAAnG,CAAD,CAAN;AACH;AACJ,KAJD;AAKH,GA5BM,CAAP;AA6BH;;AACD,SAAS/C,WAAT,CAAqBiD,OAArB,EAA8B;AAC1B,SAAOxB,OAAO,CAACb,OAAR,CAAgB,IAAhB,CAAP;AACH;;AACDhB,OAAO,CAACI,WAAR,GAAsBA,WAAtB;;AACA,eAAeD,eAAf,CAA+BsB,SAA/B,EAA0CC,SAA1C,EAAqD4B,OAArD,EAA8D3B,YAA9D,EAA4EC,IAA5E,EAAkF;AAC9E,QAAM2B,kBAAkB,GAAG,MAAM/B,aAAa,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,YAAvB,EAAqCC,IAArC,CAA9C;AACA,QAAM4B,IAAI,GAAG1D,MAAM,CAACkC,MAAP,CAAclC,MAAM,CAACkC,MAAP,CAAc,EAAd,EAAkBpB,OAAO,CAAC6C,KAAR,EAAlB,CAAd,EAAkD;AAAEC,IAAAA,oBAAoB,EAAE9B;AAAxB,GAAlD,CAAb;;AACA,OAAK,MAAM+B,UAAX,IAAyBJ,kBAAzB,EAA6C;AACzCrD,IAAAA,qBAAqB,CAACuB,SAAD,EAAY6B,OAAZ,EAAqBK,UAArB,EAAiCH,IAAjC,CAArB;AACH;;AACD,SAAOA,IAAP;AACH;;AACDxD,OAAO,CAACG,eAAR,GAA0BA,eAA1B;;AACA,SAASD,qBAAT,CAA+BuB,SAA/B,EAA0C6B,OAA1C,EAAmDK,UAAnD,EAA+DH,IAA/D,EAAqE;AACjE,MAAII,EAAJ;;AACA9D,EAAAA,MAAM,CAAC+D,MAAP,CAAcF,UAAd;;AACA,OAAK,MAAMG,MAAX,IAAqBH,UAAU,CAACI,OAAX,IAAsB,CAAClD,GAAG,CAACmD,sBAAL,CAA3C,EAAyE;AACrE,QAAIC,SAAJ;;AACA,QAAI,CAAC,CAACN,UAAU,CAACO,YAAb,IAA6B,CAAC,CAACP,UAAU,CAACQ,YAA9C,EAA4D;AACxD,YAAM,IAAIzD,OAAO,CAACwC,aAAZ,CAA0B,0FAA1B,CAAN;AACH;;AACD,QAAIS,UAAU,CAACO,YAAf,EAA6B;AACzB,YAAME,OAAO,GAAG,EAAhB;;AACA,UAAIT,UAAU,CAACU,aAAf,EAA8B;AAC1B1D,QAAAA,QAAQ,CAAC2D,MAAT,CAAgBC,IAAhB,CAAsB,4CAA2CZ,UAAU,CAACa,IAAK,EAAjF;AACH;;AACD1D,MAAAA,KAAK,CAAC2D,aAAN,CAAoBL,OAApB,EAA6BT,UAAU,CAACO,YAAxC,EAAsD,SAAtD;AACAD,MAAAA,SAAS,GAAG;AAAEC,QAAAA,YAAY,EAAEE;AAAhB,OAAZ;AACH,KAPD,MAQK,IAAIT,UAAU,CAACe,QAAf,EAAyB;AAC1BlB,MAAAA,IAAI,CAACmB,YAAL,CAAkB,QAAlB,IAA8B,uBAA9B;AACAnB,MAAAA,IAAI,CAACmB,YAAL,CAAkB,WAAlB,IAAiC,+BAAjC;AACAV,MAAAA,SAAS,GAAG;AAAEW,QAAAA,eAAe,EAAEjB,UAAU,CAACe;AAA9B,OAAZ;AACH,KAJI,MAKA;AACDT,MAAAA,SAAS,GAAG;AACRE,QAAAA,YAAY,EAAE;AACVU,UAAAA,SAAS,EAAElB,UAAU,CAACQ,YAAX,CAAwBU,SADzB;AAEVC,UAAAA,YAAY,EAAE;AACVC,YAAAA,QAAQ,EAAEpB,UAAU,CAACQ,YAAX,CAAwBY;AADxB,WAFJ;AAKVC,UAAAA,KAAK,EAAE,CAAC,CAACrB,UAAU,CAACU;AALV;AADN,OAAZ;;AASA,UAAIrE,OAAO,CAACK,UAAR,CAAmB4E,GAAnB,CAAuB,CAAC,CAACrB,EAAE,GAAGD,UAAU,CAACQ,YAAjB,MAAmC,IAAnC,IAA2CP,EAAE,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,EAAE,CAACiB,SAAxE,KAAsF,EAA7G,CAAJ,EAAsH;AAClHZ,QAAAA,SAAS,CAACE,YAAV,CAAuBW,YAAvB,GAAsC;AAClCI,UAAAA,MAAM,EAAEvB,UAAU,CAACQ,YAAX,CAAwBY;AADE,SAAtC;AAGH;AACJ;;AACD,UAAMI,QAAQ,GAAGrF,MAAM,CAACkC,MAAP,CAAc;AAAEoD,MAAAA,QAAQ,EAAEzB,UAAU,CAACyB,QAAX,IAAuB,OAAnC;AAA4CC,MAAAA,EAAE,EAAE1B,UAAU,CAACa,IAA3D;AAAiEV,MAAAA,MAAM,EAAEA,MAAzE;AAAiFwB,MAAAA,OAAO,EAAE7D,SAA1F;AAAqG8D,MAAAA,UAAU,EAAE5B,UAAU,CAAC4B,UAA5H;AAAwIjC,MAAAA,OAAO,EAAEA;AAAjJ,KAAd,EAA0KW,SAA1K,CAAjB;;AACA,QAAIN,UAAU,CAAC6B,YAAf,EAA6B;AACzB,UAAIC,OAAO,GAAG9B,UAAU,CAAC6B,YAAzB;;AACA,UAAI,CAACC,OAAO,CAACC,QAAR,CAAiB,GAAjB,CAAL,EAA4B;AACxBD,QAAAA,OAAO,GAAI,YAAWhE,SAAU,cAAaqC,MAAO,eAAc2B,OAAQ,EAA1E;AACH;;AACDN,MAAAA,QAAQ,CAACK,YAAT,GAAwBC,OAAxB;AACH;;AACD3E,IAAAA,KAAK,CAAC2D,aAAN,CAAoBU,QAApB,EAA8BxB,UAA9B,EAA0C,aAA1C,EAAyD,qBAAzD,EAAgF,QAAhF,EAA0F,4BAA1F,EAAwH,iBAAxH,EAA2I,SAA3I,EAAsJ,cAAtJ,EAAsK,cAAtK,EAAsL,mBAAtL;AACAH,IAAAA,IAAI,CAACmC,SAAL,CAAe7B,MAAf,IAAyBN,IAAI,CAACmC,SAAL,CAAe7B,MAAf,KAA0B,EAAnD;AACAN,IAAAA,IAAI,CAACmC,SAAL,CAAe7B,MAAf,EAAuBqB,QAAQ,CAACE,EAAhC,IAAsCF,QAAtC;AACH;AACJ;;AACDnF,OAAO,CAACE,qBAAR,GAAgCA,qBAAhC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addResourcesToBackend = exports.discoverBackend = exports.useStrategy = exports.GCS_EVENTS = void 0;\nconst path = require(\"path\");\nconst _ = require(\"lodash\");\nconst child_process_1 = require(\"child_process\");\nconst error_1 = require(\"../../../../error\");\nconst logger_1 = require(\"../../../../logger\");\nconst backend = require(\"../../backend\");\nconst api = require(\"../../../../api\");\nconst proto = require(\"../../../../gcp/proto\");\nconst TRIGGER_PARSER = path.resolve(__dirname, \"./triggerParser.js\");\nexports.GCS_EVENTS = new Set([\n    \"google.cloud.storage.object.v1.finalized\",\n    \"google.cloud.storage.object.v1.archived\",\n    \"google.cloud.storage.object.v1.deleted\",\n    \"google.cloud.storage.object.v1.metadataUpdated\",\n]);\nfunction removeInspectOptions(options) {\n    return options.filter((opt) => !opt.startsWith(\"--inspect\"));\n}\nfunction parseTriggers(projectId, sourceDir, configValues, envs) {\n    return new Promise((resolve, reject) => {\n        const env = Object.assign({}, envs);\n        env.GCLOUD_PROJECT = projectId;\n        if (!_.isEmpty(configValues)) {\n            env.CLOUD_RUNTIME_CONFIG = JSON.stringify(configValues);\n        }\n        const execArgv = removeInspectOptions(process.execArgv);\n        if (env.NODE_OPTIONS) {\n            env.NODE_OPTIONS = removeInspectOptions(env.NODE_OPTIONS.split(\" \")).join(\" \");\n        }\n        const parser = child_process_1.fork(TRIGGER_PARSER, [sourceDir], {\n            silent: true,\n            env: env,\n            execArgv: execArgv,\n        });\n        parser.on(\"message\", (message) => {\n            if (message.triggers) {\n                resolve(message.triggers);\n            }\n            else if (message.error) {\n                reject(new error_1.FirebaseError(message.error, { exit: 1 }));\n            }\n        });\n        parser.on(\"exit\", (code) => {\n            if (code !== 0) {\n                reject(new error_1.FirebaseError(\"There was an unknown problem while trying to parse function triggers.\", { exit: 2 }));\n            }\n        });\n    });\n}\nfunction useStrategy(context) {\n    return Promise.resolve(true);\n}\nexports.useStrategy = useStrategy;\nasync function discoverBackend(projectId, sourceDir, runtime, configValues, envs) {\n    const triggerAnnotations = await parseTriggers(projectId, sourceDir, configValues, envs);\n    const want = Object.assign(Object.assign({}, backend.empty()), { environmentVariables: envs });\n    for (const annotation of triggerAnnotations) {\n        addResourcesToBackend(projectId, runtime, annotation, want);\n    }\n    return want;\n}\nexports.discoverBackend = discoverBackend;\nfunction addResourcesToBackend(projectId, runtime, annotation, want) {\n    var _a;\n    Object.freeze(annotation);\n    for (const region of annotation.regions || [api.functionsDefaultRegion]) {\n        let triggered;\n        if (!!annotation.httpsTrigger == !!annotation.eventTrigger) {\n            throw new error_1.FirebaseError(\"Unexpected annotation generated by the Firebase Functions SDK. This should never happen.\");\n        }\n        if (annotation.httpsTrigger) {\n            const trigger = {};\n            if (annotation.failurePolicy) {\n                logger_1.logger.warn(`Ignoring retry policy for HTTPS function ${annotation.name}`);\n            }\n            proto.copyIfPresent(trigger, annotation.httpsTrigger, \"invoker\");\n            triggered = { httpsTrigger: trigger };\n        }\n        else if (annotation.schedule) {\n            want.requiredAPIs[\"pubsub\"] = \"pubsub.googleapis.com\";\n            want.requiredAPIs[\"scheduler\"] = \"cloudscheduler.googleapis.com\";\n            triggered = { scheduleTrigger: annotation.schedule };\n        }\n        else {\n            triggered = {\n                eventTrigger: {\n                    eventType: annotation.eventTrigger.eventType,\n                    eventFilters: {\n                        resource: annotation.eventTrigger.resource,\n                    },\n                    retry: !!annotation.failurePolicy,\n                },\n            };\n            if (exports.GCS_EVENTS.has(((_a = annotation.eventTrigger) === null || _a === void 0 ? void 0 : _a.eventType) || \"\")) {\n                triggered.eventTrigger.eventFilters = {\n                    bucket: annotation.eventTrigger.resource,\n                };\n            }\n        }\n        const endpoint = Object.assign({ platform: annotation.platform || \"gcfv1\", id: annotation.name, region: region, project: projectId, entryPoint: annotation.entryPoint, runtime: runtime }, triggered);\n        if (annotation.vpcConnector) {\n            let maybeId = annotation.vpcConnector;\n            if (!maybeId.includes(\"/\")) {\n                maybeId = `projects/${projectId}/locations/${region}/connectors/${maybeId}`;\n            }\n            endpoint.vpcConnector = maybeId;\n        }\n        proto.copyIfPresent(endpoint, annotation, \"concurrency\", \"serviceAccountEmail\", \"labels\", \"vpcConnectorEgressSettings\", \"ingressSettings\", \"timeout\", \"maxInstances\", \"minInstances\", \"availableMemoryMb\");\n        want.endpoints[region] = want.endpoints[region] || {};\n        want.endpoints[region][endpoint.id] = endpoint;\n    }\n}\nexports.addResourcesToBackend = addResourcesToBackend;\n"]},"metadata":{},"sourceType":"script"}