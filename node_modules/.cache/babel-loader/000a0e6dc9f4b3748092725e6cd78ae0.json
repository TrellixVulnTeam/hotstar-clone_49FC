{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.backendFromV1Alpha1 = void 0;\n\nconst backend = require(\"../../backend\");\n\nconst proto_1 = require(\"../../../../gcp/proto\");\n\nconst parsing_1 = require(\"./parsing\");\n\nconst error_1 = require(\"../../../../error\");\n\nfunction backendFromV1Alpha1(yaml, project, region, runtime) {\n  const manifest = JSON.parse(JSON.stringify(yaml));\n  const bkend = backend.empty();\n  bkend.requiredAPIs = parseRequiredAPIs(manifest);\n  parsing_1.requireKeys(\"\", manifest, \"endpoints\");\n  parsing_1.assertKeyTypes(\"\", manifest, {\n    specVersion: \"string\",\n    requiredAPIs: \"object\",\n    endpoints: \"object\"\n  });\n\n  for (const id of Object.keys(manifest.endpoints)) {\n    for (const parsed of parseEndpoints(manifest, id, project, region, runtime)) {\n      bkend.endpoints[parsed.region] = bkend.endpoints[parsed.region] || {};\n      bkend.endpoints[parsed.region][parsed.id] = parsed;\n    }\n  }\n\n  return bkend;\n}\n\nexports.backendFromV1Alpha1 = backendFromV1Alpha1;\n\nfunction parseRequiredAPIs(manifest) {\n  const requiredAPIs = {};\n\n  if (typeof manifest !== \"object\" || Array.isArray(manifest)) {\n    throw new error_1.FirebaseError(\"Expected requiredApis to be a map of string to string\");\n  }\n\n  for (const [api, reason] of Object.entries(manifest.requiredAPIs || {})) {\n    if (typeof reason !== \"string\") {\n      throw new error_1.FirebaseError(`Invalid reason \"${JSON.stringify(reason)} for API ${api}. Expected string`);\n    }\n\n    requiredAPIs[api] = reason;\n  }\n\n  return requiredAPIs;\n}\n\nfunction parseEndpoints(manifest, id, project, defaultRegion, runtime) {\n  const allParsed = [];\n  const prefix = `endpoints[${id}]`;\n  const ep = manifest.endpoints[id];\n  parsing_1.assertKeyTypes(prefix, ep, {\n    region: \"array\",\n    platform: \"string\",\n    entryPoint: \"string\",\n    availableMemoryMb: \"number\",\n    maxInstances: \"number\",\n    minInstances: \"number\",\n    concurrency: \"number\",\n    serviceAccountEmail: \"string\",\n    timeout: \"string\",\n    vpcConnector: \"string\",\n    vpcConnectorEgressSettings: \"string\",\n    labels: \"object\",\n    ingressSettings: \"string\",\n    environmentVariables: \"object\",\n    httpsTrigger: \"object\",\n    eventTrigger: \"object\",\n    scheduleTrigger: \"object\"\n  });\n  let triggerCount = 0;\n\n  if (ep.httpsTrigger) {\n    triggerCount++;\n  }\n\n  if (ep.eventTrigger) {\n    triggerCount++;\n  }\n\n  if (ep.scheduleTrigger) {\n    triggerCount++;\n  }\n\n  if (!triggerCount) {\n    throw new error_1.FirebaseError(\"Expected trigger in endpoint\" + id);\n  }\n\n  if (triggerCount > 1) {\n    throw new error_1.FirebaseError(\"Multiple triggers defined for endpoint\" + id);\n  }\n\n  for (const region of ep.region || [defaultRegion]) {\n    let triggered;\n\n    if (backend.isEventTriggered(ep)) {\n      parsing_1.requireKeys(prefix + \".eventTrigger\", ep.eventTrigger, \"eventType\", \"eventFilters\");\n      parsing_1.assertKeyTypes(prefix + \".eventTrigger\", ep.eventTrigger, {\n        eventFilters: \"object\",\n        eventType: \"string\",\n        retry: \"boolean\",\n        region: \"string\",\n        serviceAccountEmail: \"string\"\n      });\n      triggered = {\n        eventTrigger: ep.eventTrigger\n      };\n    } else if (backend.isHttpsTriggered(ep)) {\n      parsing_1.assertKeyTypes(prefix + \".httpsTrigger\", ep.httpsTrigger, {\n        invoker: \"array\"\n      });\n      triggered = {\n        httpsTrigger: {}\n      };\n      proto_1.copyIfPresent(triggered.httpsTrigger, ep.httpsTrigger, \"invoker\");\n    } else if (backend.isScheduleTriggered(ep)) {\n      parsing_1.assertKeyTypes(prefix + \".scheduleTrigger\", ep.scheduleTrigger, {\n        schedule: \"string\",\n        timeZone: \"string\",\n        retryConfig: \"object\"\n      });\n      parsing_1.assertKeyTypes(prefix + \".scheduleTrigger.retryConfig\", ep.scheduleTrigger.retryConfig, {\n        retryCount: \"number\",\n        maxDoublings: \"number\",\n        minBackoffDuration: \"string\",\n        maxBackoffDuration: \"string\",\n        maxRetryDuration: \"string\"\n      });\n      triggered = {\n        scheduleTrigger: ep.scheduleTrigger\n      };\n    } else {\n      throw new error_1.FirebaseError(`Do not recognize trigger type for endpoint ${id}. Try upgrading ` + \"firebase-tools with npm install -g firebase-tools@latest\");\n    }\n\n    parsing_1.requireKeys(prefix, ep, \"entryPoint\");\n    const parsed = Object.assign({\n      platform: ep.platform || \"gcfv2\",\n      id,\n      region,\n      project,\n      runtime,\n      entryPoint: ep.entryPoint\n    }, triggered);\n    proto_1.copyIfPresent(parsed, ep, \"availableMemoryMb\", \"maxInstances\", \"minInstances\", \"concurrency\", \"serviceAccountEmail\", \"timeout\", \"vpcConnector\", \"vpcConnectorEgressSettings\", \"labels\", \"ingressSettings\", \"environmentVariables\");\n    allParsed.push(parsed);\n  }\n\n  return allParsed;\n}","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/deploy/functions/runtimes/discovery/v1alpha1.js"],"names":["Object","defineProperty","exports","value","backendFromV1Alpha1","backend","require","proto_1","parsing_1","error_1","yaml","project","region","runtime","manifest","JSON","parse","stringify","bkend","empty","requiredAPIs","parseRequiredAPIs","requireKeys","assertKeyTypes","specVersion","endpoints","id","keys","parsed","parseEndpoints","Array","isArray","FirebaseError","api","reason","entries","defaultRegion","allParsed","prefix","ep","platform","entryPoint","availableMemoryMb","maxInstances","minInstances","concurrency","serviceAccountEmail","timeout","vpcConnector","vpcConnectorEgressSettings","labels","ingressSettings","environmentVariables","httpsTrigger","eventTrigger","scheduleTrigger","triggerCount","triggered","isEventTriggered","eventFilters","eventType","retry","isHttpsTriggered","invoker","copyIfPresent","isScheduleTriggered","schedule","timeZone","retryConfig","retryCount","maxDoublings","minBackoffDuration","maxBackoffDuration","maxRetryDuration","assign","push"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.backendFromV1Alpha1 = void 0;\nconst backend = require(\"../../backend\");\nconst proto_1 = require(\"../../../../gcp/proto\");\nconst parsing_1 = require(\"./parsing\");\nconst error_1 = require(\"../../../../error\");\nfunction backendFromV1Alpha1(yaml, project, region, runtime) {\n    const manifest = JSON.parse(JSON.stringify(yaml));\n    const bkend = backend.empty();\n    bkend.requiredAPIs = parseRequiredAPIs(manifest);\n    parsing_1.requireKeys(\"\", manifest, \"endpoints\");\n    parsing_1.assertKeyTypes(\"\", manifest, {\n        specVersion: \"string\",\n        requiredAPIs: \"object\",\n        endpoints: \"object\",\n    });\n    for (const id of Object.keys(manifest.endpoints)) {\n        for (const parsed of parseEndpoints(manifest, id, project, region, runtime)) {\n            bkend.endpoints[parsed.region] = bkend.endpoints[parsed.region] || {};\n            bkend.endpoints[parsed.region][parsed.id] = parsed;\n        }\n    }\n    return bkend;\n}\nexports.backendFromV1Alpha1 = backendFromV1Alpha1;\nfunction parseRequiredAPIs(manifest) {\n    const requiredAPIs = {};\n    if (typeof manifest !== \"object\" || Array.isArray(manifest)) {\n        throw new error_1.FirebaseError(\"Expected requiredApis to be a map of string to string\");\n    }\n    for (const [api, reason] of Object.entries(manifest.requiredAPIs || {})) {\n        if (typeof reason !== \"string\") {\n            throw new error_1.FirebaseError(`Invalid reason \"${JSON.stringify(reason)} for API ${api}. Expected string`);\n        }\n        requiredAPIs[api] = reason;\n    }\n    return requiredAPIs;\n}\nfunction parseEndpoints(manifest, id, project, defaultRegion, runtime) {\n    const allParsed = [];\n    const prefix = `endpoints[${id}]`;\n    const ep = manifest.endpoints[id];\n    parsing_1.assertKeyTypes(prefix, ep, {\n        region: \"array\",\n        platform: \"string\",\n        entryPoint: \"string\",\n        availableMemoryMb: \"number\",\n        maxInstances: \"number\",\n        minInstances: \"number\",\n        concurrency: \"number\",\n        serviceAccountEmail: \"string\",\n        timeout: \"string\",\n        vpcConnector: \"string\",\n        vpcConnectorEgressSettings: \"string\",\n        labels: \"object\",\n        ingressSettings: \"string\",\n        environmentVariables: \"object\",\n        httpsTrigger: \"object\",\n        eventTrigger: \"object\",\n        scheduleTrigger: \"object\",\n    });\n    let triggerCount = 0;\n    if (ep.httpsTrigger) {\n        triggerCount++;\n    }\n    if (ep.eventTrigger) {\n        triggerCount++;\n    }\n    if (ep.scheduleTrigger) {\n        triggerCount++;\n    }\n    if (!triggerCount) {\n        throw new error_1.FirebaseError(\"Expected trigger in endpoint\" + id);\n    }\n    if (triggerCount > 1) {\n        throw new error_1.FirebaseError(\"Multiple triggers defined for endpoint\" + id);\n    }\n    for (const region of ep.region || [defaultRegion]) {\n        let triggered;\n        if (backend.isEventTriggered(ep)) {\n            parsing_1.requireKeys(prefix + \".eventTrigger\", ep.eventTrigger, \"eventType\", \"eventFilters\");\n            parsing_1.assertKeyTypes(prefix + \".eventTrigger\", ep.eventTrigger, {\n                eventFilters: \"object\",\n                eventType: \"string\",\n                retry: \"boolean\",\n                region: \"string\",\n                serviceAccountEmail: \"string\",\n            });\n            triggered = { eventTrigger: ep.eventTrigger };\n        }\n        else if (backend.isHttpsTriggered(ep)) {\n            parsing_1.assertKeyTypes(prefix + \".httpsTrigger\", ep.httpsTrigger, {\n                invoker: \"array\",\n            });\n            triggered = { httpsTrigger: {} };\n            proto_1.copyIfPresent(triggered.httpsTrigger, ep.httpsTrigger, \"invoker\");\n        }\n        else if (backend.isScheduleTriggered(ep)) {\n            parsing_1.assertKeyTypes(prefix + \".scheduleTrigger\", ep.scheduleTrigger, {\n                schedule: \"string\",\n                timeZone: \"string\",\n                retryConfig: \"object\",\n            });\n            parsing_1.assertKeyTypes(prefix + \".scheduleTrigger.retryConfig\", ep.scheduleTrigger.retryConfig, {\n                retryCount: \"number\",\n                maxDoublings: \"number\",\n                minBackoffDuration: \"string\",\n                maxBackoffDuration: \"string\",\n                maxRetryDuration: \"string\",\n            });\n            triggered = { scheduleTrigger: ep.scheduleTrigger };\n        }\n        else {\n            throw new error_1.FirebaseError(`Do not recognize trigger type for endpoint ${id}. Try upgrading ` +\n                \"firebase-tools with npm install -g firebase-tools@latest\");\n        }\n        parsing_1.requireKeys(prefix, ep, \"entryPoint\");\n        const parsed = Object.assign({ platform: ep.platform || \"gcfv2\", id,\n            region,\n            project,\n            runtime, entryPoint: ep.entryPoint }, triggered);\n        proto_1.copyIfPresent(parsed, ep, \"availableMemoryMb\", \"maxInstances\", \"minInstances\", \"concurrency\", \"serviceAccountEmail\", \"timeout\", \"vpcConnector\", \"vpcConnectorEgressSettings\", \"labels\", \"ingressSettings\", \"environmentVariables\");\n        allParsed.push(parsed);\n    }\n    return allParsed;\n}\n"]},"metadata":{},"sourceType":"script"}