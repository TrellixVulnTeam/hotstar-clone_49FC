{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FlowControlledPublisher = void 0;\n\nconst pubsub_message_1 = require(\"./pubsub-message\");\n/**\n * Encapsulates a series of message publishes from a rapid loop (or similar\n * circumstance).\n *\n * This class is not meant to be instantiated outside of the `@google-cloud/pubsub`\n * package. It is returned from {@link Topic#flowControlled}. Messages sent\n * through an instance of this class will obey publisher flow control\n * settings set through {@link PublisherOptions} on {@link Topic}, across\n * all instances returned by {@link Topic#flowControlled} on that {@link Topic}.\n */\n\n\nclass FlowControlledPublisher {\n  constructor(publisher) {\n    this.publisher = publisher;\n    this.flowControl = this.publisher.flowControl;\n    this.idPromises = [];\n  }\n  /**\n   * Returns true if sending the specified Buffer would result in exceeding the\n   * limits of the flow control settings.\n   *\n   * @param {PubsubMessage} message The data buffer with the message's contents.\n   * @returns {boolean} True if the message would exceed flow control limits.\n   */\n\n\n  wouldExceed(message) {\n    return this.flowControl.wouldExceed(pubsub_message_1.calculateMessageSize(message), 1);\n  }\n  /**\n   * Publishes a message, subject to flow control restrictions.\n   *\n   * If the message can be sent immediately, this will return `null`. Otherwise,\n   * it will return a Promise<void> that resolves after it's okay to resume\n   * calling the method.\n   *\n   * @param {Buffer} [data] The message contents to be sent.\n   * @param {Attributes} [attributes] Optional attributes.\n   * @returns null, or a Promise that resolves when sending may resume.\n   *\n   * @example\n   * const wait = flowControlled.publish({data});\n   * if (wait) {\n   *   await wait;\n   * }\n   *\n   * @example\n   * // It's okay to await unconditionally, it's equivalent to nextTick().\n   * await flowControlled.publish(data);\n   */\n\n\n  publish(message) {\n    const doPublish = () => {\n      this.doPublish(message);\n    };\n\n    const size = pubsub_message_1.calculateMessageSize(message);\n\n    if (this.flowControl.wouldExceed(size, 1)) {\n      const waitPromise = this.flowControl.willSend(size, 1);\n      return waitPromise.then(doPublish);\n    } else {\n      this.flowControl.willSend(size, 1).then(() => {});\n      doPublish();\n      return null;\n    }\n  }\n  /**\n   * Publishes a message unconditionally, updating flow control counters.\n   *\n   * You'll generally only want to use this if you want to deal with timing the\n   * flow control yourself, but you'd like the library to do the bean counting.\n   *\n   * @param {Buffer} [data] The message contents to be sent.\n   * @param {Attributes} [attributes] Optional attributes.\n   *\n   * @example\n   * if (!flowControlled.wouldExceed(data)) {\n   *   flowControlled.publishNow(data);\n   * }\n   */\n\n\n  publishNow(message) {\n    this.flowControl.addToCount(pubsub_message_1.calculateMessageSize(message), 1);\n    this.doPublish(message);\n  }\n\n  doPublish(message) {\n    let idPromise = this.publisher.publishMessage(message); // This will defer but not eat any errors.\n\n    const publishDone = id => {\n      this.flowControl.sent(pubsub_message_1.calculateMessageSize(message), 1);\n      return id;\n    };\n\n    idPromise.catch(publishDone);\n    idPromise = idPromise.then(publishDone);\n    this.idPromises.push(idPromise);\n  }\n  /**\n   * Returns a Promise that will resolve to all of the currently sent\n   * message IDs (or reject if there is an error). This also clears\n   * out any currently sent messages, so the next call to `all()` will\n   * be a clean slate.\n   *\n   * @returns {Promise<string[]>} A Promise that resolves when all current\n   *   messages are sent.\n   */\n\n\n  all() {\n    const allPromise = Promise.all(this.idPromises);\n    this.idPromises = [];\n    return allPromise;\n  }\n\n}\n\nexports.FlowControlledPublisher = FlowControlledPublisher;","map":{"version":3,"sources":["../../../src/publisher/flow-publisher.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;AAIH,MAAA,gBAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;AAEA;;;;;;;;;AASG;;;AACH,MAAa,uBAAb,CAAoC;AAKlC,EAAA,WAAA,CAAY,SAAZ,EAAgC;AAC9B,SAAK,SAAL,GAAiB,SAAjB;AACA,SAAK,WAAL,GAAmB,KAAK,SAAL,CAAe,WAAlC;AACA,SAAK,UAAL,GAAkB,EAAlB;AACD;AAED;;;;;;AAMG;;;AACH,EAAA,WAAW,CAAC,OAAD,EAAuB;AAChC,WAAO,KAAK,WAAL,CAAiB,WAAjB,CAA6B,gBAAA,CAAA,oBAAA,CAAqB,OAArB,CAA7B,EAA4D,CAA5D,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;AAoBG;;;AACH,EAAA,OAAO,CAAC,OAAD,EAAuB;AAC5B,UAAM,SAAS,GAAG,MAAK;AACrB,WAAK,SAAL,CAAe,OAAf;AACD,KAFD;;AAIA,UAAM,IAAI,GAAG,gBAAA,CAAA,oBAAA,CAAqB,OAArB,CAAb;;AACA,QAAI,KAAK,WAAL,CAAiB,WAAjB,CAA6B,IAA7B,EAAmC,CAAnC,CAAJ,EAA2C;AACzC,YAAM,WAAW,GAAG,KAAK,WAAL,CAAiB,QAAjB,CAA0B,IAA1B,EAAgC,CAAhC,CAApB;AACA,aAAO,WAAW,CAAC,IAAZ,CAAiB,SAAjB,CAAP;AACD,KAHD,MAGO;AACL,WAAK,WAAL,CAAiB,QAAjB,CAA0B,IAA1B,EAAgC,CAAhC,EAAmC,IAAnC,CAAwC,MAAK,CAAG,CAAhD;AACA,MAAA,SAAS;AACT,aAAO,IAAP;AACD;AACF;AAED;;;;;;;;;;;;;AAaG;;;AACH,EAAA,UAAU,CAAC,OAAD,EAAuB;AAC/B,SAAK,WAAL,CAAiB,UAAjB,CAA4B,gBAAA,CAAA,oBAAA,CAAqB,OAArB,CAA5B,EAA2D,CAA3D;AACA,SAAK,SAAL,CAAe,OAAf;AACD;;AAEO,EAAA,SAAS,CAAC,OAAD,EAAuB;AACtC,QAAI,SAAS,GAAG,KAAK,SAAL,CAAe,cAAf,CAA8B,OAA9B,CAAhB,CADsC,CAGtC;;AACA,UAAM,WAAW,GAAI,EAAD,IAAe;AACjC,WAAK,WAAL,CAAiB,IAAjB,CAAsB,gBAAA,CAAA,oBAAA,CAAqB,OAArB,CAAtB,EAAqD,CAArD;AACA,aAAO,EAAP;AACD,KAHD;;AAIA,IAAA,SAAS,CAAC,KAAV,CAAgB,WAAhB;AACA,IAAA,SAAS,GAAG,SAAS,CAAC,IAAV,CAAe,WAAf,CAAZ;AAEA,SAAK,UAAL,CAAgB,IAAhB,CAAqB,SAArB;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,GAAG,GAAA;AACD,UAAM,UAAU,GAAG,OAAO,CAAC,GAAR,CAAY,KAAK,UAAjB,CAAnB;AACA,SAAK,UAAL,GAAkB,EAAlB;AACA,WAAO,UAAP;AACD;;AAzGiC;;AAApC,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlowControlledPublisher = void 0;\nconst pubsub_message_1 = require(\"./pubsub-message\");\n/**\n * Encapsulates a series of message publishes from a rapid loop (or similar\n * circumstance).\n *\n * This class is not meant to be instantiated outside of the `@google-cloud/pubsub`\n * package. It is returned from {@link Topic#flowControlled}. Messages sent\n * through an instance of this class will obey publisher flow control\n * settings set through {@link PublisherOptions} on {@link Topic}, across\n * all instances returned by {@link Topic#flowControlled} on that {@link Topic}.\n */\nclass FlowControlledPublisher {\n    constructor(publisher) {\n        this.publisher = publisher;\n        this.flowControl = this.publisher.flowControl;\n        this.idPromises = [];\n    }\n    /**\n     * Returns true if sending the specified Buffer would result in exceeding the\n     * limits of the flow control settings.\n     *\n     * @param {PubsubMessage} message The data buffer with the message's contents.\n     * @returns {boolean} True if the message would exceed flow control limits.\n     */\n    wouldExceed(message) {\n        return this.flowControl.wouldExceed(pubsub_message_1.calculateMessageSize(message), 1);\n    }\n    /**\n     * Publishes a message, subject to flow control restrictions.\n     *\n     * If the message can be sent immediately, this will return `null`. Otherwise,\n     * it will return a Promise<void> that resolves after it's okay to resume\n     * calling the method.\n     *\n     * @param {Buffer} [data] The message contents to be sent.\n     * @param {Attributes} [attributes] Optional attributes.\n     * @returns null, or a Promise that resolves when sending may resume.\n     *\n     * @example\n     * const wait = flowControlled.publish({data});\n     * if (wait) {\n     *   await wait;\n     * }\n     *\n     * @example\n     * // It's okay to await unconditionally, it's equivalent to nextTick().\n     * await flowControlled.publish(data);\n     */\n    publish(message) {\n        const doPublish = () => {\n            this.doPublish(message);\n        };\n        const size = pubsub_message_1.calculateMessageSize(message);\n        if (this.flowControl.wouldExceed(size, 1)) {\n            const waitPromise = this.flowControl.willSend(size, 1);\n            return waitPromise.then(doPublish);\n        }\n        else {\n            this.flowControl.willSend(size, 1).then(() => { });\n            doPublish();\n            return null;\n        }\n    }\n    /**\n     * Publishes a message unconditionally, updating flow control counters.\n     *\n     * You'll generally only want to use this if you want to deal with timing the\n     * flow control yourself, but you'd like the library to do the bean counting.\n     *\n     * @param {Buffer} [data] The message contents to be sent.\n     * @param {Attributes} [attributes] Optional attributes.\n     *\n     * @example\n     * if (!flowControlled.wouldExceed(data)) {\n     *   flowControlled.publishNow(data);\n     * }\n     */\n    publishNow(message) {\n        this.flowControl.addToCount(pubsub_message_1.calculateMessageSize(message), 1);\n        this.doPublish(message);\n    }\n    doPublish(message) {\n        let idPromise = this.publisher.publishMessage(message);\n        // This will defer but not eat any errors.\n        const publishDone = (id) => {\n            this.flowControl.sent(pubsub_message_1.calculateMessageSize(message), 1);\n            return id;\n        };\n        idPromise.catch(publishDone);\n        idPromise = idPromise.then(publishDone);\n        this.idPromises.push(idPromise);\n    }\n    /**\n     * Returns a Promise that will resolve to all of the currently sent\n     * message IDs (or reject if there is an error). This also clears\n     * out any currently sent messages, so the next call to `all()` will\n     * be a clean slate.\n     *\n     * @returns {Promise<string[]>} A Promise that resolves when all current\n     *   messages are sent.\n     */\n    all() {\n        const allPromise = Promise.all(this.idPromises);\n        this.idPromises = [];\n        return allPromise;\n    }\n}\nexports.FlowControlledPublisher = FlowControlledPublisher;\n//# sourceMappingURL=flow-publisher.js.map"]},"metadata":{},"sourceType":"script"}