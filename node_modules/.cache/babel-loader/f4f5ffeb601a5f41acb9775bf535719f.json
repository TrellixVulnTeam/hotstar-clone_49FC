{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferUpdateSource = exports.updateFromPublisherSource = exports.updateToVersionFromPublisherSource = exports.updateFromUrlSource = exports.updateFromLocalSource = exports.update = exports.displayChanges = exports.warningUpdateToOtherSource = exports.getExistingSourceOrigin = void 0;\n\nconst clc = require(\"cli-color\");\n\nconst semver = require(\"semver\");\n\nconst marked = require(\"marked\");\n\nconst error_1 = require(\"../error\");\n\nconst logger_1 = require(\"../logger\");\n\nconst resolveSource = require(\"./resolveSource\");\n\nconst extensionsApi = require(\"./extensionsApi\");\n\nconst refs = require(\"./refs\");\n\nconst extensionsHelper_1 = require(\"./extensionsHelper\");\n\nconst utils = require(\"../utils\");\n\nconst displayExtensionInfo_1 = require(\"./displayExtensionInfo\");\n\nconst changelog = require(\"./changelog\");\n\nfunction invalidSourceErrMsgTemplate(instanceId, source) {\n  return `Unable to update from the source \\`${clc.bold(source)}\\`. To update this instance, you can either:\\n\n  - Run \\`${clc.bold(\"firebase ext:update \" + instanceId)}\\` to update from the published source.\\n\n  - Check your directory path or URL, then run \\`${clc.bold(\"firebase ext:update \" + instanceId + \" <otherSource>\")}\\` to update from a local directory or URL source.`;\n}\n\nasync function getExistingSourceOrigin(projectId, instanceId, extensionName, existingSource) {\n  const instance = await extensionsApi.getInstance(projectId, instanceId);\n  return instance && instance.config.extensionRef ? extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION : extensionsHelper_1.SourceOrigin.LOCAL;\n}\n\nexports.getExistingSourceOrigin = getExistingSourceOrigin;\n\nfunction showUpdateVersionInfo(instanceId, from, to, source) {\n  if (source) {\n    source = clc.bold(source);\n  } else {\n    source = \"version\";\n  }\n\n  utils.logLabeledBullet(extensionsHelper_1.logPrefix, `Updating ${clc.bold(instanceId)} from version ${clc.bold(from)} to ${source} (${clc.bold(to)})`);\n\n  if (semver.lt(to, from)) {\n    utils.logLabeledWarning(extensionsHelper_1.logPrefix, \"The version you are updating to is less than the current version for this extension. This extension may not be backwards compatible.\");\n  }\n\n  return;\n}\n\nfunction warningUpdateToOtherSource(sourceOrigin) {\n  let targetText;\n\n  if ([extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION, extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION_VERSION].includes(sourceOrigin)) {\n    targetText = \"published extension\";\n  } else if (sourceOrigin === extensionsHelper_1.SourceOrigin.LOCAL) {\n    targetText = \"local directory\";\n  } else if (sourceOrigin === extensionsHelper_1.SourceOrigin.URL) {\n    targetText = \"URL\";\n  }\n\n  const warning = `All the instance's resources and logic will be overwritten to use the source code and files from the ${targetText}.\\n`;\n  logger_1.logger.info(marked(warning));\n}\n\nexports.warningUpdateToOtherSource = warningUpdateToOtherSource;\n\nasync function displayChanges(args) {\n  utils.logLabeledBullet(\"extensions\", \"This update contains the following changes:\");\n  displayExtensionInfo_1.displayUpdateChangesNoInput(args.spec, args.newSpec);\n  await displayExtensionInfo_1.displayUpdateChangesRequiringConfirmation(args);\n}\n\nexports.displayChanges = displayChanges;\n\nasync function update(updateOptions) {\n  const {\n    projectId,\n    instanceId,\n    source,\n    extRef,\n    params\n  } = updateOptions;\n\n  if (extRef) {\n    return await extensionsApi.updateInstanceFromRegistry(projectId, instanceId, extRef, params);\n  } else if (source) {\n    return await extensionsApi.updateInstance(projectId, instanceId, source, params);\n  }\n\n  throw new error_1.FirebaseError(`Neither a source nor a version of the extension was supplied for ${instanceId}. Please make sure this is a valid extension and try again.`);\n}\n\nexports.update = update;\n\nasync function updateFromLocalSource(projectId, instanceId, localSource, existingSpec) {\n  displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n  let source;\n\n  try {\n    source = await extensionsHelper_1.createSourceFromLocation(projectId, localSource);\n  } catch (err) {\n    throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, localSource));\n  }\n\n  utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a local source.\")}`);\n  showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, localSource);\n  warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.LOCAL);\n  return source.name;\n}\n\nexports.updateFromLocalSource = updateFromLocalSource;\n\nasync function updateFromUrlSource(projectId, instanceId, urlSource, existingSpec) {\n  displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n  let source;\n\n  try {\n    source = await extensionsHelper_1.createSourceFromLocation(projectId, urlSource);\n  } catch (err) {\n    throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, urlSource));\n  }\n\n  utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a URL source.\")}`);\n  showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, urlSource);\n  warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.URL);\n  return source.name;\n}\n\nexports.updateFromUrlSource = updateFromUrlSource;\n\nasync function updateToVersionFromPublisherSource(projectId, instanceId, extVersionRef, existingSpec) {\n  let source;\n  const ref = refs.parse(extVersionRef);\n  const version = ref.version;\n  const extensionRef = refs.toExtensionRef(ref);\n  displayExtensionInfo_1.displayExtInfo(instanceId, ref.publisherId, existingSpec, true);\n  const extension = await extensionsApi.getExtension(extensionRef);\n\n  try {\n    source = await extensionsApi.getExtensionVersion(extVersionRef);\n  } catch (err) {\n    throw new error_1.FirebaseError(`Could not find source '${clc.bold(extVersionRef)}' because (${clc.bold(version)}) is not a published version. To update, use the latest version of this extension (${clc.bold(extension.latestVersion)}).`);\n  }\n\n  let registryEntry;\n\n  try {\n    registryEntry = await resolveSource.resolveRegistryEntry(existingSpec.name);\n  } catch (err) {\n    logger_1.logger.debug(`Unable to fetch registry.json entry for ${existingSpec.name}`);\n  }\n\n  if (registryEntry) {\n    const minVer = resolveSource.getMinRequiredVersion(registryEntry);\n\n    if (minVer && semver.gt(minVer, source.spec.version)) {\n      throw new error_1.FirebaseError(`The version you are trying to update to (${clc.bold(source.spec.version)}) is less than the minimum version required (${clc.bold(minVer)}) to use this extension.`);\n    }\n  }\n\n  showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, extVersionRef);\n  warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION);\n  const releaseNotes = await changelog.getReleaseNotesForUpdate({\n    extensionRef,\n    fromVersion: existingSpec.version,\n    toVersion: source.spec.version\n  });\n\n  if (Object.keys(releaseNotes).length) {\n    changelog.displayReleaseNotes(releaseNotes, existingSpec.version);\n  }\n\n  return source.name;\n}\n\nexports.updateToVersionFromPublisherSource = updateToVersionFromPublisherSource;\n\nasync function updateFromPublisherSource(projectId, instanceId, extRef, existingSpec) {\n  return updateToVersionFromPublisherSource(projectId, instanceId, `${extRef}@latest`, existingSpec);\n}\n\nexports.updateFromPublisherSource = updateFromPublisherSource;\n\nfunction inferUpdateSource(updateSource, existingRef) {\n  if (!updateSource) {\n    return `${existingRef}@latest`;\n  }\n\n  if (semver.valid(updateSource)) {\n    return `${existingRef}@${updateSource}`;\n  }\n\n  if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && updateSource.split(\"/\").length < 2) {\n    return updateSource.includes(\"@\") ? `firebase/${updateSource}` : `firebase/${updateSource}@latest`;\n  }\n\n  if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && !updateSource.includes(\"@\")) {\n    return `${updateSource}@latest`;\n  }\n\n  return updateSource;\n}\n\nexports.inferUpdateSource = inferUpdateSource;","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/extensions/updateHelper.js"],"names":["Object","defineProperty","exports","value","inferUpdateSource","updateFromPublisherSource","updateToVersionFromPublisherSource","updateFromUrlSource","updateFromLocalSource","update","displayChanges","warningUpdateToOtherSource","getExistingSourceOrigin","clc","require","semver","marked","error_1","logger_1","resolveSource","extensionsApi","refs","extensionsHelper_1","utils","displayExtensionInfo_1","changelog","invalidSourceErrMsgTemplate","instanceId","source","bold","projectId","extensionName","existingSource","instance","getInstance","config","extensionRef","SourceOrigin","PUBLISHED_EXTENSION","LOCAL","showUpdateVersionInfo","from","to","logLabeledBullet","logPrefix","lt","logLabeledWarning","sourceOrigin","targetText","PUBLISHED_EXTENSION_VERSION","includes","URL","warning","logger","info","args","displayUpdateChangesNoInput","spec","newSpec","displayUpdateChangesRequiringConfirmation","updateOptions","extRef","params","updateInstanceFromRegistry","updateInstance","FirebaseError","localSource","existingSpec","displayExtInfo","createSourceFromLocation","err","version","name","urlSource","extVersionRef","ref","parse","toExtensionRef","publisherId","extension","getExtension","getExtensionVersion","latestVersion","registryEntry","resolveRegistryEntry","debug","minVer","getMinRequiredVersion","gt","releaseNotes","getReleaseNotesForUpdate","fromVersion","toVersion","keys","length","displayReleaseNotes","updateSource","existingRef","valid","isLocalOrURLPath","split"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.inferUpdateSource = exports.updateFromPublisherSource = exports.updateToVersionFromPublisherSource = exports.updateFromUrlSource = exports.updateFromLocalSource = exports.update = exports.displayChanges = exports.warningUpdateToOtherSource = exports.getExistingSourceOrigin = void 0;\nconst clc = require(\"cli-color\");\nconst semver = require(\"semver\");\nconst marked = require(\"marked\");\nconst error_1 = require(\"../error\");\nconst logger_1 = require(\"../logger\");\nconst resolveSource = require(\"./resolveSource\");\nconst extensionsApi = require(\"./extensionsApi\");\nconst refs = require(\"./refs\");\nconst extensionsHelper_1 = require(\"./extensionsHelper\");\nconst utils = require(\"../utils\");\nconst displayExtensionInfo_1 = require(\"./displayExtensionInfo\");\nconst changelog = require(\"./changelog\");\nfunction invalidSourceErrMsgTemplate(instanceId, source) {\n    return `Unable to update from the source \\`${clc.bold(source)}\\`. To update this instance, you can either:\\n\n  - Run \\`${clc.bold(\"firebase ext:update \" + instanceId)}\\` to update from the published source.\\n\n  - Check your directory path or URL, then run \\`${clc.bold(\"firebase ext:update \" + instanceId + \" <otherSource>\")}\\` to update from a local directory or URL source.`;\n}\nasync function getExistingSourceOrigin(projectId, instanceId, extensionName, existingSource) {\n    const instance = await extensionsApi.getInstance(projectId, instanceId);\n    return instance && instance.config.extensionRef\n        ? extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION\n        : extensionsHelper_1.SourceOrigin.LOCAL;\n}\nexports.getExistingSourceOrigin = getExistingSourceOrigin;\nfunction showUpdateVersionInfo(instanceId, from, to, source) {\n    if (source) {\n        source = clc.bold(source);\n    }\n    else {\n        source = \"version\";\n    }\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `Updating ${clc.bold(instanceId)} from version ${clc.bold(from)} to ${source} (${clc.bold(to)})`);\n    if (semver.lt(to, from)) {\n        utils.logLabeledWarning(extensionsHelper_1.logPrefix, \"The version you are updating to is less than the current version for this extension. This extension may not be backwards compatible.\");\n    }\n    return;\n}\nfunction warningUpdateToOtherSource(sourceOrigin) {\n    let targetText;\n    if ([extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION, extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION_VERSION].includes(sourceOrigin)) {\n        targetText = \"published extension\";\n    }\n    else if (sourceOrigin === extensionsHelper_1.SourceOrigin.LOCAL) {\n        targetText = \"local directory\";\n    }\n    else if (sourceOrigin === extensionsHelper_1.SourceOrigin.URL) {\n        targetText = \"URL\";\n    }\n    const warning = `All the instance's resources and logic will be overwritten to use the source code and files from the ${targetText}.\\n`;\n    logger_1.logger.info(marked(warning));\n}\nexports.warningUpdateToOtherSource = warningUpdateToOtherSource;\nasync function displayChanges(args) {\n    utils.logLabeledBullet(\"extensions\", \"This update contains the following changes:\");\n    displayExtensionInfo_1.displayUpdateChangesNoInput(args.spec, args.newSpec);\n    await displayExtensionInfo_1.displayUpdateChangesRequiringConfirmation(args);\n}\nexports.displayChanges = displayChanges;\nasync function update(updateOptions) {\n    const { projectId, instanceId, source, extRef, params } = updateOptions;\n    if (extRef) {\n        return await extensionsApi.updateInstanceFromRegistry(projectId, instanceId, extRef, params);\n    }\n    else if (source) {\n        return await extensionsApi.updateInstance(projectId, instanceId, source, params);\n    }\n    throw new error_1.FirebaseError(`Neither a source nor a version of the extension was supplied for ${instanceId}. Please make sure this is a valid extension and try again.`);\n}\nexports.update = update;\nasync function updateFromLocalSource(projectId, instanceId, localSource, existingSpec) {\n    displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n    let source;\n    try {\n        source = await extensionsHelper_1.createSourceFromLocation(projectId, localSource);\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, localSource));\n    }\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a local source.\")}`);\n    showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, localSource);\n    warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.LOCAL);\n    return source.name;\n}\nexports.updateFromLocalSource = updateFromLocalSource;\nasync function updateFromUrlSource(projectId, instanceId, urlSource, existingSpec) {\n    displayExtensionInfo_1.displayExtInfo(instanceId, \"\", existingSpec, false);\n    let source;\n    try {\n        source = await extensionsHelper_1.createSourceFromLocation(projectId, urlSource);\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(invalidSourceErrMsgTemplate(instanceId, urlSource));\n    }\n    utils.logLabeledBullet(extensionsHelper_1.logPrefix, `${clc.bold(\"You are updating this extension instance to a URL source.\")}`);\n    showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, urlSource);\n    warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.URL);\n    return source.name;\n}\nexports.updateFromUrlSource = updateFromUrlSource;\nasync function updateToVersionFromPublisherSource(projectId, instanceId, extVersionRef, existingSpec) {\n    let source;\n    const ref = refs.parse(extVersionRef);\n    const version = ref.version;\n    const extensionRef = refs.toExtensionRef(ref);\n    displayExtensionInfo_1.displayExtInfo(instanceId, ref.publisherId, existingSpec, true);\n    const extension = await extensionsApi.getExtension(extensionRef);\n    try {\n        source = await extensionsApi.getExtensionVersion(extVersionRef);\n    }\n    catch (err) {\n        throw new error_1.FirebaseError(`Could not find source '${clc.bold(extVersionRef)}' because (${clc.bold(version)}) is not a published version. To update, use the latest version of this extension (${clc.bold(extension.latestVersion)}).`);\n    }\n    let registryEntry;\n    try {\n        registryEntry = await resolveSource.resolveRegistryEntry(existingSpec.name);\n    }\n    catch (err) {\n        logger_1.logger.debug(`Unable to fetch registry.json entry for ${existingSpec.name}`);\n    }\n    if (registryEntry) {\n        const minVer = resolveSource.getMinRequiredVersion(registryEntry);\n        if (minVer && semver.gt(minVer, source.spec.version)) {\n            throw new error_1.FirebaseError(`The version you are trying to update to (${clc.bold(source.spec.version)}) is less than the minimum version required (${clc.bold(minVer)}) to use this extension.`);\n        }\n    }\n    showUpdateVersionInfo(instanceId, existingSpec.version, source.spec.version, extVersionRef);\n    warningUpdateToOtherSource(extensionsHelper_1.SourceOrigin.PUBLISHED_EXTENSION);\n    const releaseNotes = await changelog.getReleaseNotesForUpdate({\n        extensionRef,\n        fromVersion: existingSpec.version,\n        toVersion: source.spec.version,\n    });\n    if (Object.keys(releaseNotes).length) {\n        changelog.displayReleaseNotes(releaseNotes, existingSpec.version);\n    }\n    return source.name;\n}\nexports.updateToVersionFromPublisherSource = updateToVersionFromPublisherSource;\nasync function updateFromPublisherSource(projectId, instanceId, extRef, existingSpec) {\n    return updateToVersionFromPublisherSource(projectId, instanceId, `${extRef}@latest`, existingSpec);\n}\nexports.updateFromPublisherSource = updateFromPublisherSource;\nfunction inferUpdateSource(updateSource, existingRef) {\n    if (!updateSource) {\n        return `${existingRef}@latest`;\n    }\n    if (semver.valid(updateSource)) {\n        return `${existingRef}@${updateSource}`;\n    }\n    if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && updateSource.split(\"/\").length < 2) {\n        return updateSource.includes(\"@\")\n            ? `firebase/${updateSource}`\n            : `firebase/${updateSource}@latest`;\n    }\n    if (!extensionsHelper_1.isLocalOrURLPath(updateSource) && !updateSource.includes(\"@\")) {\n        return `${updateSource}@latest`;\n    }\n    return updateSource;\n}\nexports.inferUpdateSource = inferUpdateSource;\n"]},"metadata":{},"sourceType":"script"}