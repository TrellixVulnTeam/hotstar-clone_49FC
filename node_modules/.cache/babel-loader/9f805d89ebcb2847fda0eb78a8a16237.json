{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FlowControl = void 0;\n\nconst defer = require(\"p-defer\");\n/**\n * Manages flow control handling for max bytes and messages.\n *\n * Do not use this class externally, it may change without warning.\n * @private\n *\n */\n\n\nclass FlowControl {\n  constructor(options) {\n    this.options = {};\n    this.setOptions(options);\n    this.bytes = this.messages = 0;\n    this.requests = [];\n  }\n  /**\n   * Update our options after the fact.\n   *\n   * Do not use externally, it may change without warning.\n   * @private\n   */\n\n\n  setOptions(options) {\n    this.options = options;\n\n    if (this.options.maxOutstandingBytes === 0 || this.options.maxOutstandingMessages === 0) {\n      // Undefined is okay, but if either is zero, no publishes ever happen.\n      throw new Error('When using publisher flow control, maxOutstandingBytes and maxOutstandingMessages must not be zero');\n    }\n  }\n  /**\n   * @returns {number} The number of bytes that are queued up.\n   */\n\n\n  get currentByteCount() {\n    return this.bytes;\n  }\n  /**\n   * @returns {number} The number of messages that are queued up.\n   */\n\n\n  get currentMessageCount() {\n    return this.messages;\n  }\n  /**\n   * Adds the specified number of bytes or messages to our count. We'll\n   * assume that this is end running around our queueing mechanisms.\n   *\n   * @param {number} bytes The number of bytes to add to the count.\n   * @param {number} messages The number of messages to add to the count.\n   */\n\n\n  addToCount(bytes, messages) {\n    this.bytes += bytes;\n    this.messages += messages;\n  }\n  /**\n   * Attempts to queue the specified number of bytes and messages. If\n   * there are too many things in the publisher flow control queue\n   * already, we will defer and come back to it.\n   *\n   * Do not use externally, it may change without warning.\n   * @private\n   */\n\n\n  async willSend(bytes, messages) {\n    // Add this to our queue size.\n    this.bytes += bytes;\n    this.messages += messages; // If this request won't fit, we have to put it in the queue.\n\n    if (this.exceeded()) {\n      const promise = defer();\n      this.requests.push({\n        promise: promise.promise,\n        resolve: promise.resolve,\n        reject: promise.reject,\n        bytes,\n        messageCount: messages\n      }); // This will pass through when someone else's this.sent() completes.\n\n      await promise.promise;\n    }\n  }\n  /**\n   * Removes the specified number of bytes and messages from our queued\n   * counts, after a deferred request was released. If there is enough\n   * space.\n   *\n   * Do not use externally, it may change without warning.\n   * @private\n   */\n\n\n  sent(bytes, messages) {\n    this.bytes -= bytes;\n    this.messages -= messages; // This shouldn't happen, but just be sure.\n\n    if (this.bytes < 0) this.bytes = 0;\n    if (this.messages < 0) this.messages = 0; // Let things waiting on willSend() have a go, if there's space.\n\n    if (this.requests.length > 0 && !this.exceeded()) {\n      const next = this.requests.shift();\n      next.resolve();\n    }\n  } // Just uses wouldExceed() to see if we've already exceeded the limits.\n\n\n  exceeded() {\n    return this.wouldExceed(0, 0);\n  }\n  /**\n   * Returns true if adding the specified number of bytes or messages\n   * would exceed limits imposed by configuration.\n   *\n   * Do not use externally, it may change without warning.\n   * @private\n   */\n\n\n  wouldExceed(bytes, messages) {\n    const totalBytes = this.bytes + bytes;\n    const totalMessages = this.messages + messages;\n\n    if (this.options.maxOutstandingBytes !== undefined && totalBytes > this.options.maxOutstandingBytes) {\n      return true;\n    }\n\n    if (this.options.maxOutstandingMessages !== undefined && totalMessages > this.options.maxOutstandingMessages) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.FlowControl = FlowControl;","map":{"version":3,"sources":["../../../src/publisher/flow-control.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FlowControl = void 0;\nconst defer = require(\"p-defer\");\n/**\n * Manages flow control handling for max bytes and messages.\n *\n * Do not use this class externally, it may change without warning.\n * @private\n *\n */\nclass FlowControl {\n    constructor(options) {\n        this.options = {};\n        this.setOptions(options);\n        this.bytes = this.messages = 0;\n        this.requests = [];\n    }\n    /**\n     * Update our options after the fact.\n     *\n     * Do not use externally, it may change without warning.\n     * @private\n     */\n    setOptions(options) {\n        this.options = options;\n        if (this.options.maxOutstandingBytes === 0 ||\n            this.options.maxOutstandingMessages === 0) {\n            // Undefined is okay, but if either is zero, no publishes ever happen.\n            throw new Error('When using publisher flow control, maxOutstandingBytes and maxOutstandingMessages must not be zero');\n        }\n    }\n    /**\n     * @returns {number} The number of bytes that are queued up.\n     */\n    get currentByteCount() {\n        return this.bytes;\n    }\n    /**\n     * @returns {number} The number of messages that are queued up.\n     */\n    get currentMessageCount() {\n        return this.messages;\n    }\n    /**\n     * Adds the specified number of bytes or messages to our count. We'll\n     * assume that this is end running around our queueing mechanisms.\n     *\n     * @param {number} bytes The number of bytes to add to the count.\n     * @param {number} messages The number of messages to add to the count.\n     */\n    addToCount(bytes, messages) {\n        this.bytes += bytes;\n        this.messages += messages;\n    }\n    /**\n     * Attempts to queue the specified number of bytes and messages. If\n     * there are too many things in the publisher flow control queue\n     * already, we will defer and come back to it.\n     *\n     * Do not use externally, it may change without warning.\n     * @private\n     */\n    async willSend(bytes, messages) {\n        // Add this to our queue size.\n        this.bytes += bytes;\n        this.messages += messages;\n        // If this request won't fit, we have to put it in the queue.\n        if (this.exceeded()) {\n            const promise = defer();\n            this.requests.push({\n                promise: promise.promise,\n                resolve: promise.resolve,\n                reject: promise.reject,\n                bytes,\n                messageCount: messages,\n            });\n            // This will pass through when someone else's this.sent() completes.\n            await promise.promise;\n        }\n    }\n    /**\n     * Removes the specified number of bytes and messages from our queued\n     * counts, after a deferred request was released. If there is enough\n     * space.\n     *\n     * Do not use externally, it may change without warning.\n     * @private\n     */\n    sent(bytes, messages) {\n        this.bytes -= bytes;\n        this.messages -= messages;\n        // This shouldn't happen, but just be sure.\n        if (this.bytes < 0)\n            this.bytes = 0;\n        if (this.messages < 0)\n            this.messages = 0;\n        // Let things waiting on willSend() have a go, if there's space.\n        if (this.requests.length > 0 && !this.exceeded()) {\n            const next = this.requests.shift();\n            next.resolve();\n        }\n    }\n    // Just uses wouldExceed() to see if we've already exceeded the limits.\n    exceeded() {\n        return this.wouldExceed(0, 0);\n    }\n    /**\n     * Returns true if adding the specified number of bytes or messages\n     * would exceed limits imposed by configuration.\n     *\n     * Do not use externally, it may change without warning.\n     * @private\n     */\n    wouldExceed(bytes, messages) {\n        const totalBytes = this.bytes + bytes;\n        const totalMessages = this.messages + messages;\n        if (this.options.maxOutstandingBytes !== undefined &&\n            totalBytes > this.options.maxOutstandingBytes) {\n            return true;\n        }\n        if (this.options.maxOutstandingMessages !== undefined &&\n            totalMessages > this.options.maxOutstandingMessages) {\n            return true;\n        }\n        return false;\n    }\n}\nexports.FlowControl = FlowControl;\n//# sourceMappingURL=flow-control.js.map"]},"metadata":{},"sourceType":"script"}