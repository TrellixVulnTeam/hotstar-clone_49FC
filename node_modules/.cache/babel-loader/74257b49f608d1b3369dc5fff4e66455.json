{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.promptForMinInstances = exports.promptForFunctionDeletion = exports.promptForFailurePolicies = void 0;\n\nconst clc = require(\"cli-color\");\n\nconst functionsDeployHelper_1 = require(\"./functionsDeployHelper\");\n\nconst error_1 = require(\"../../error\");\n\nconst prompt_1 = require(\"../../prompt\");\n\nconst logger_1 = require(\"../../logger\");\n\nconst backend = require(\"./backend\");\n\nconst pricing = require(\"./pricing\");\n\nconst utils = require(\"../../utils\");\n\nasync function promptForFailurePolicies(options, want, have) {\n  const retryEndpoints = backend.allEndpoints(want).filter(e => {\n    return backend.isEventTriggered(e) && e.eventTrigger.retry;\n  });\n\n  if (retryEndpoints.length === 0) {\n    return;\n  }\n\n  const newRetryEndpoints = retryEndpoints.filter(endpoint => {\n    var _a;\n\n    const existing = (_a = have.endpoints[endpoint.region]) === null || _a === void 0 ? void 0 : _a[endpoint.id];\n    return !(existing && backend.isEventTriggered(existing) && existing.eventTrigger.retry);\n  });\n\n  if (newRetryEndpoints.length == 0) {\n    return;\n  }\n\n  const warnMessage = \"The following functions will newly be retried in case of failure: \" + clc.bold(newRetryEndpoints.sort(backend.compareFunctions).map(functionsDeployHelper_1.getFunctionLabel).join(\", \")) + \". \" + \"Retried executions are billed as any other execution, and functions are retried repeatedly until they either successfully execute or the maximum retry period has elapsed, which can be up to 7 days. \" + \"For safety, you might want to ensure that your functions are idempotent; see https://firebase.google.com/docs/functions/retries to learn more.\";\n  utils.logLabeledWarning(\"functions\", warnMessage);\n\n  if (options.force) {\n    return;\n  }\n\n  if (options.nonInteractive) {\n    throw new error_1.FirebaseError(\"Pass the --force option to deploy functions with a failure policy\", {\n      exit: 1\n    });\n  }\n\n  const proceed = await prompt_1.promptOnce({\n    type: \"confirm\",\n    name: \"confirm\",\n    default: false,\n    message: \"Would you like to proceed with deployment?\"\n  });\n\n  if (!proceed) {\n    throw new error_1.FirebaseError(\"Deployment canceled.\", {\n      exit: 1\n    });\n  }\n}\n\nexports.promptForFailurePolicies = promptForFailurePolicies;\n\nasync function promptForFunctionDeletion(functionsToDelete, force, nonInteractive) {\n  let shouldDeleteFns = true;\n\n  if (functionsToDelete.length === 0 || force) {\n    return true;\n  }\n\n  const deleteList = functionsToDelete.sort(backend.compareFunctions).map(fn => \"\\t\" + functionsDeployHelper_1.getFunctionLabel(fn)).join(\"\\n\");\n\n  if (nonInteractive) {\n    const deleteCommands = functionsToDelete.map(func => {\n      return \"\\tfirebase functions:delete \" + func.id + \" --region \" + func.region;\n    }).join(\"\\n\");\n    throw new error_1.FirebaseError(\"The following functions are found in your project but do not exist in your local source code:\\n\" + deleteList + \"\\n\\nAborting because deletion cannot proceed in non-interactive mode. To fix, manually delete the functions by running:\\n\" + clc.bold(deleteCommands));\n  } else {\n    logger_1.logger.info(\"\\nThe following functions are found in your project but do not exist in your local source code:\\n\" + deleteList + \"\\n\\nIf you are renaming a function or changing its region, it is recommended that you create the new \" + \"function first before deleting the old one to prevent event loss. For more info, visit \" + clc.underline(\"https://firebase.google.com/docs/functions/manage-functions#modify\" + \"\\n\"));\n    shouldDeleteFns = await prompt_1.promptOnce({\n      type: \"confirm\",\n      name: \"confirm\",\n      default: false,\n      message: \"Would you like to proceed with deletion? Selecting no will continue the rest of the deployments.\"\n    });\n  }\n\n  return shouldDeleteFns;\n}\n\nexports.promptForFunctionDeletion = promptForFunctionDeletion;\n\nasync function promptForMinInstances(options, want, have) {\n  if (options.force) {\n    return;\n  }\n\n  const increasesCost = backend.someEndpoint(want, wantE => {\n    var _a;\n\n    if (!pricing.canCalculateMinInstanceCost(wantE)) {\n      return true;\n    }\n\n    const wantCost = pricing.monthlyMinInstanceCost([wantE]);\n    const haveE = (_a = have.endpoints[wantE.region]) === null || _a === void 0 ? void 0 : _a[wantE.id];\n    let haveCost;\n\n    if (!haveE) {\n      haveCost = 0;\n    } else if (!pricing.canCalculateMinInstanceCost(wantE)) {\n      return true;\n    } else {\n      haveCost = pricing.monthlyMinInstanceCost([haveE]);\n    }\n\n    return wantCost > haveCost;\n  });\n\n  if (!increasesCost) {\n    return;\n  }\n\n  if (options.nonInteractive) {\n    throw new error_1.FirebaseError(\"Pass the --force option to deploy functions that increase the minimum bill\", {\n      exit: 1\n    });\n  }\n\n  const functionLines = backend.allEndpoints(want).filter(fn => fn.minInstances).sort(backend.compareFunctions).map(fn => {\n    return `\\t${functionsDeployHelper_1.getFunctionLabel(fn)}: ${fn.minInstances} instances, ` + backend.memoryOptionDisplayName(fn.availableMemoryMb || 256) + \" of memory each\";\n  }).join(\"\\n\");\n  let costLine;\n\n  if (backend.someEndpoint(want, fn => !pricing.canCalculateMinInstanceCost(fn))) {\n    costLine = \"Cannot calculate the minimum monthly bill for this configuration. Consider running \" + clc.bold(\"npm install -g firebase-tools\");\n  } else {\n    const cost = pricing.monthlyMinInstanceCost(backend.allEndpoints(want)).toFixed(2);\n    costLine = `With these options, your minimum bill will be $${cost} in a 30-day month`;\n  }\n\n  let cudAnnotation = \"\";\n\n  if (backend.someEndpoint(want, fn => fn.platform == \"gcfv2\" && !!fn.minInstances)) {\n    cudAnnotation = \"\\nThis bill can be lowered with a one year commitment. See https://cloud.google.com/run/cud for more\";\n  }\n\n  const warnMessage = \"The following functions have reserved minimum instances. This will \" + \"reduce the frequency of cold starts but increases the minimum cost. \" + \"You will be charged for the memory allocation and a fraction of the \" + \"CPU allocation of instances while they are idle.\\n\\n\" + functionLines + \"\\n\\n\" + costLine + cudAnnotation;\n  utils.logLabeledWarning(\"functions\", warnMessage);\n  const proceed = await prompt_1.promptOnce({\n    type: \"confirm\",\n    name: \"confirm\",\n    default: false,\n    message: \"Would you like to proceed with deployment?\"\n  });\n\n  if (!proceed) {\n    throw new error_1.FirebaseError(\"Deployment canceled.\", {\n      exit: 1\n    });\n  }\n}\n\nexports.promptForMinInstances = promptForMinInstances;","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/deploy/functions/prompts.js"],"names":["Object","defineProperty","exports","value","promptForMinInstances","promptForFunctionDeletion","promptForFailurePolicies","clc","require","functionsDeployHelper_1","error_1","prompt_1","logger_1","backend","pricing","utils","options","want","have","retryEndpoints","allEndpoints","filter","e","isEventTriggered","eventTrigger","retry","length","newRetryEndpoints","endpoint","_a","existing","endpoints","region","id","warnMessage","bold","sort","compareFunctions","map","getFunctionLabel","join","logLabeledWarning","force","nonInteractive","FirebaseError","exit","proceed","promptOnce","type","name","default","message","functionsToDelete","shouldDeleteFns","deleteList","fn","deleteCommands","func","logger","info","underline","increasesCost","someEndpoint","wantE","canCalculateMinInstanceCost","wantCost","monthlyMinInstanceCost","haveE","haveCost","functionLines","minInstances","memoryOptionDisplayName","availableMemoryMb","costLine","cost","toFixed","cudAnnotation","platform"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.promptForMinInstances = exports.promptForFunctionDeletion = exports.promptForFailurePolicies = void 0;\nconst clc = require(\"cli-color\");\nconst functionsDeployHelper_1 = require(\"./functionsDeployHelper\");\nconst error_1 = require(\"../../error\");\nconst prompt_1 = require(\"../../prompt\");\nconst logger_1 = require(\"../../logger\");\nconst backend = require(\"./backend\");\nconst pricing = require(\"./pricing\");\nconst utils = require(\"../../utils\");\nasync function promptForFailurePolicies(options, want, have) {\n    const retryEndpoints = backend.allEndpoints(want).filter((e) => {\n        return backend.isEventTriggered(e) && e.eventTrigger.retry;\n    });\n    if (retryEndpoints.length === 0) {\n        return;\n    }\n    const newRetryEndpoints = retryEndpoints.filter((endpoint) => {\n        var _a;\n        const existing = (_a = have.endpoints[endpoint.region]) === null || _a === void 0 ? void 0 : _a[endpoint.id];\n        return !(existing && backend.isEventTriggered(existing) && existing.eventTrigger.retry);\n    });\n    if (newRetryEndpoints.length == 0) {\n        return;\n    }\n    const warnMessage = \"The following functions will newly be retried in case of failure: \" +\n        clc.bold(newRetryEndpoints.sort(backend.compareFunctions).map(functionsDeployHelper_1.getFunctionLabel).join(\", \")) +\n        \". \" +\n        \"Retried executions are billed as any other execution, and functions are retried repeatedly until they either successfully execute or the maximum retry period has elapsed, which can be up to 7 days. \" +\n        \"For safety, you might want to ensure that your functions are idempotent; see https://firebase.google.com/docs/functions/retries to learn more.\";\n    utils.logLabeledWarning(\"functions\", warnMessage);\n    if (options.force) {\n        return;\n    }\n    if (options.nonInteractive) {\n        throw new error_1.FirebaseError(\"Pass the --force option to deploy functions with a failure policy\", {\n            exit: 1,\n        });\n    }\n    const proceed = await prompt_1.promptOnce({\n        type: \"confirm\",\n        name: \"confirm\",\n        default: false,\n        message: \"Would you like to proceed with deployment?\",\n    });\n    if (!proceed) {\n        throw new error_1.FirebaseError(\"Deployment canceled.\", { exit: 1 });\n    }\n}\nexports.promptForFailurePolicies = promptForFailurePolicies;\nasync function promptForFunctionDeletion(functionsToDelete, force, nonInteractive) {\n    let shouldDeleteFns = true;\n    if (functionsToDelete.length === 0 || force) {\n        return true;\n    }\n    const deleteList = functionsToDelete\n        .sort(backend.compareFunctions)\n        .map((fn) => \"\\t\" + functionsDeployHelper_1.getFunctionLabel(fn))\n        .join(\"\\n\");\n    if (nonInteractive) {\n        const deleteCommands = functionsToDelete\n            .map((func) => {\n            return \"\\tfirebase functions:delete \" + func.id + \" --region \" + func.region;\n        })\n            .join(\"\\n\");\n        throw new error_1.FirebaseError(\"The following functions are found in your project but do not exist in your local source code:\\n\" +\n            deleteList +\n            \"\\n\\nAborting because deletion cannot proceed in non-interactive mode. To fix, manually delete the functions by running:\\n\" +\n            clc.bold(deleteCommands));\n    }\n    else {\n        logger_1.logger.info(\"\\nThe following functions are found in your project but do not exist in your local source code:\\n\" +\n            deleteList +\n            \"\\n\\nIf you are renaming a function or changing its region, it is recommended that you create the new \" +\n            \"function first before deleting the old one to prevent event loss. For more info, visit \" +\n            clc.underline(\"https://firebase.google.com/docs/functions/manage-functions#modify\" + \"\\n\"));\n        shouldDeleteFns = await prompt_1.promptOnce({\n            type: \"confirm\",\n            name: \"confirm\",\n            default: false,\n            message: \"Would you like to proceed with deletion? Selecting no will continue the rest of the deployments.\",\n        });\n    }\n    return shouldDeleteFns;\n}\nexports.promptForFunctionDeletion = promptForFunctionDeletion;\nasync function promptForMinInstances(options, want, have) {\n    if (options.force) {\n        return;\n    }\n    const increasesCost = backend.someEndpoint(want, (wantE) => {\n        var _a;\n        if (!pricing.canCalculateMinInstanceCost(wantE)) {\n            return true;\n        }\n        const wantCost = pricing.monthlyMinInstanceCost([wantE]);\n        const haveE = (_a = have.endpoints[wantE.region]) === null || _a === void 0 ? void 0 : _a[wantE.id];\n        let haveCost;\n        if (!haveE) {\n            haveCost = 0;\n        }\n        else if (!pricing.canCalculateMinInstanceCost(wantE)) {\n            return true;\n        }\n        else {\n            haveCost = pricing.monthlyMinInstanceCost([haveE]);\n        }\n        return wantCost > haveCost;\n    });\n    if (!increasesCost) {\n        return;\n    }\n    if (options.nonInteractive) {\n        throw new error_1.FirebaseError(\"Pass the --force option to deploy functions that increase the minimum bill\", {\n            exit: 1,\n        });\n    }\n    const functionLines = backend\n        .allEndpoints(want)\n        .filter((fn) => fn.minInstances)\n        .sort(backend.compareFunctions)\n        .map((fn) => {\n        return (`\\t${functionsDeployHelper_1.getFunctionLabel(fn)}: ${fn.minInstances} instances, ` +\n            backend.memoryOptionDisplayName(fn.availableMemoryMb || 256) +\n            \" of memory each\");\n    })\n        .join(\"\\n\");\n    let costLine;\n    if (backend.someEndpoint(want, (fn) => !pricing.canCalculateMinInstanceCost(fn))) {\n        costLine =\n            \"Cannot calculate the minimum monthly bill for this configuration. Consider running \" +\n                clc.bold(\"npm install -g firebase-tools\");\n    }\n    else {\n        const cost = pricing.monthlyMinInstanceCost(backend.allEndpoints(want)).toFixed(2);\n        costLine = `With these options, your minimum bill will be $${cost} in a 30-day month`;\n    }\n    let cudAnnotation = \"\";\n    if (backend.someEndpoint(want, (fn) => fn.platform == \"gcfv2\" && !!fn.minInstances)) {\n        cudAnnotation =\n            \"\\nThis bill can be lowered with a one year commitment. See https://cloud.google.com/run/cud for more\";\n    }\n    const warnMessage = \"The following functions have reserved minimum instances. This will \" +\n        \"reduce the frequency of cold starts but increases the minimum cost. \" +\n        \"You will be charged for the memory allocation and a fraction of the \" +\n        \"CPU allocation of instances while they are idle.\\n\\n\" +\n        functionLines +\n        \"\\n\\n\" +\n        costLine +\n        cudAnnotation;\n    utils.logLabeledWarning(\"functions\", warnMessage);\n    const proceed = await prompt_1.promptOnce({\n        type: \"confirm\",\n        name: \"confirm\",\n        default: false,\n        message: \"Would you like to proceed with deployment?\",\n    });\n    if (!proceed) {\n        throw new error_1.FirebaseError(\"Deployment canceled.\", { exit: 1 });\n    }\n}\nexports.promptForMinInstances = promptForMinInstances;\n"]},"metadata":{},"sourceType":"script"}