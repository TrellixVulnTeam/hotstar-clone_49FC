{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setAccountInfoImpl = exports.resetPassword = exports.SESSION_COOKIE_MAX_VALID_DURATION = exports.CUSTOM_TOKEN_AUDIENCE = exports.authOperations = void 0;\n\nconst url_1 = require(\"url\");\n\nconst jsonwebtoken_1 = require(\"jsonwebtoken\");\n\nconst utils_1 = require(\"./utils\");\n\nconst errors_1 = require(\"./errors\");\n\nconst types_1 = require(\"../types\");\n\nconst emulatorLogger_1 = require(\"../emulatorLogger\");\n\nconst state_1 = require(\"./state\");\n\nexports.authOperations = {\n  identitytoolkit: {\n    getProjects,\n    getRecaptchaParams,\n    accounts: {\n      createAuthUri,\n      delete: deleteAccount,\n      lookup,\n      resetPassword,\n      sendOobCode,\n      sendVerificationCode,\n      signInWithCustomToken,\n      signInWithEmailLink,\n      signInWithIdp,\n      signInWithPassword,\n      signInWithPhoneNumber,\n      signUp,\n      update: setAccountInfo,\n      mfaEnrollment: {\n        finalize: mfaEnrollmentFinalize,\n        start: mfaEnrollmentStart,\n        withdraw: mfaEnrollmentWithdraw\n      },\n      mfaSignIn: {\n        start: mfaSignInStart,\n        finalize: mfaSignInFinalize\n      }\n    },\n    projects: {\n      createSessionCookie,\n      queryAccounts,\n      accounts: {\n        _: signUp,\n        delete: deleteAccount,\n        lookup,\n        query: queryAccounts,\n        sendOobCode,\n        update: setAccountInfo,\n        batchCreate,\n        batchDelete,\n        batchGet\n      },\n      tenants: {\n        create: createTenant,\n        delete: deleteTenant,\n        get: getTenant,\n        list: listTenants,\n        patch: updateTenant,\n        createSessionCookie,\n        accounts: {\n          _: signUp,\n          batchCreate,\n          batchDelete,\n          batchGet,\n          delete: deleteAccount,\n          lookup,\n          query: queryAccounts,\n          sendOobCode,\n          update: setAccountInfo\n        }\n      }\n    }\n  },\n  securetoken: {\n    token: grantToken\n  },\n  emulator: {\n    projects: {\n      accounts: {\n        delete: deleteAllAccountsInProject\n      },\n      config: {\n        get: getEmulatorProjectConfig,\n        update: updateEmulatorProjectConfig\n      },\n      oobCodes: {\n        list: listOobCodesInProject\n      },\n      verificationCodes: {\n        list: listVerificationCodesInProject\n      }\n    }\n  }\n};\nconst PASSWORD_MIN_LENGTH = 6;\nexports.CUSTOM_TOKEN_AUDIENCE = \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\";\nconst MFA_INELIGIBLE_PROVIDER = new Set([state_1.PROVIDER_ANONYMOUS, state_1.PROVIDER_PHONE, state_1.PROVIDER_CUSTOM, state_1.PROVIDER_GAME_CENTER]);\n\nfunction signUp(state, reqBody, ctx) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  let provider;\n  const updates = {\n    lastLoginAt: Date.now().toString()\n  };\n\n  if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n    if (reqBody.idToken) {\n      errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n    }\n\n    if (reqBody.localId) {\n      errors_1.assert(!state.getUserByLocalId(reqBody.localId), \"DUPLICATE_LOCAL_ID\");\n    }\n\n    updates.displayName = reqBody.displayName;\n    updates.photoUrl = reqBody.photoUrl;\n    updates.emailVerified = reqBody.emailVerified || false;\n\n    if (reqBody.phoneNumber) {\n      errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n      errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n      updates.phoneNumber = reqBody.phoneNumber;\n    }\n\n    if (reqBody.disabled) {\n      updates.disabled = true;\n    }\n  } else {\n    errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n\n    if (reqBody.idToken || reqBody.password || reqBody.email) {\n      updates.displayName = reqBody.displayName;\n      updates.emailVerified = false;\n      errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n      errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n      provider = state_1.PROVIDER_PASSWORD;\n      errors_1.assert(state.allowPasswordSignup, \"OPERATION_NOT_ALLOWED\");\n    } else {\n      provider = state_1.PROVIDER_ANONYMOUS;\n      errors_1.assert(state.enableAnonymousUser, \"ADMIN_ONLY_OPERATION\");\n    }\n  }\n\n  if (reqBody.email) {\n    errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n    const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n    errors_1.assert(!state.getUserByEmail(email), \"EMAIL_EXISTS\");\n    updates.email = email;\n  }\n\n  if (reqBody.password) {\n    errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n    updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n    updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n    updates.passwordUpdatedAt = Date.now();\n    updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n  }\n\n  if (reqBody.mfaInfo) {\n    updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfaInfo, {\n      generateEnrollmentIds: true\n    });\n  }\n\n  if (state instanceof state_1.TenantProjectState) {\n    updates.tenantId = state.tenantId;\n  }\n\n  let user;\n\n  if (reqBody.idToken) {\n    ({\n      user\n    } = parseIdToken(state, reqBody.idToken));\n  }\n\n  if (!user) {\n    if (reqBody.localId) {\n      user = state.createUserWithLocalId(reqBody.localId, updates);\n      errors_1.assert(user, \"DUPLICATE_LOCAL_ID\");\n    } else {\n      user = state.createUser(updates);\n    }\n  } else {\n    user = state.updateUserByLocalId(user.localId, updates);\n  }\n\n  return Object.assign({\n    kind: \"identitytoolkit#SignupNewUserResponse\",\n    localId: user.localId,\n    displayName: user.displayName,\n    email: user.email\n  }, provider ? issueTokens(state, user, provider) : {});\n}\n\nfunction lookup(state, reqBody, ctx) {\n  var _a, _b, _c, _d, _e;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  const seenLocalIds = new Set();\n  const users = [];\n\n  function tryAddUser(maybeUser) {\n    if (maybeUser && !seenLocalIds.has(maybeUser.localId)) {\n      users.push(maybeUser);\n      seenLocalIds.add(maybeUser.localId);\n    }\n  }\n\n  if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n    if (reqBody.initialEmail) {\n      throw new errors_1.NotImplementedError(\"Lookup by initialEmail is not implemented.\");\n    }\n\n    for (const localId of (_b = reqBody.localId) !== null && _b !== void 0 ? _b : []) {\n      tryAddUser(state.getUserByLocalId(localId));\n    }\n\n    for (const email of (_c = reqBody.email) !== null && _c !== void 0 ? _c : []) {\n      tryAddUser(state.getUserByEmail(email));\n    }\n\n    for (const phoneNumber of (_d = reqBody.phoneNumber) !== null && _d !== void 0 ? _d : []) {\n      tryAddUser(state.getUserByPhoneNumber(phoneNumber));\n    }\n\n    for (const {\n      providerId,\n      rawId\n    } of (_e = reqBody.federatedUserId) !== null && _e !== void 0 ? _e : []) {\n      if (!providerId || !rawId) {\n        continue;\n      }\n\n      tryAddUser(state.getUserByProviderRawId(providerId, rawId));\n    }\n  } else {\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    const {\n      user\n    } = parseIdToken(state, reqBody.idToken);\n    users.push(redactPasswordHash(user));\n  }\n\n  return {\n    kind: \"identitytoolkit#GetAccountInfoResponse\",\n    users: users.length ? users : undefined\n  };\n}\n\nfunction batchCreate(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert((_a = reqBody.users) === null || _a === void 0 ? void 0 : _a.length, \"MISSING_USER_ACCOUNT\");\n\n  if (reqBody.sanityCheck) {\n    if (state.oneAccountPerEmail) {\n      const existingEmails = new Set();\n\n      for (const userInfo of reqBody.users) {\n        if (userInfo.email) {\n          errors_1.assert(!existingEmails.has(userInfo.email), `DUPLICATE_EMAIL : ${userInfo.email}`);\n          existingEmails.add(userInfo.email);\n        }\n      }\n    }\n\n    const existingProviderAccounts = new Set();\n\n    for (const userInfo of reqBody.users) {\n      for (const {\n        providerId,\n        rawId\n      } of (_b = userInfo.providerUserInfo) !== null && _b !== void 0 ? _b : []) {\n        const key = `${providerId}:${rawId}`;\n        errors_1.assert(!existingProviderAccounts.has(key), `DUPLICATE_RAW_ID : Provider id(${providerId}), Raw id(${rawId})`);\n        existingProviderAccounts.add(key);\n      }\n    }\n  }\n\n  if (!reqBody.allowOverwrite) {\n    const existingLocalIds = new Set();\n\n    for (const userInfo of reqBody.users) {\n      const localId = userInfo.localId || \"\";\n      errors_1.assert(!existingLocalIds.has(localId), `DUPLICATE_LOCAL_ID : ${localId}`);\n      existingLocalIds.add(localId);\n    }\n  }\n\n  const errors = [];\n\n  for (let index = 0; index < reqBody.users.length; index++) {\n    const userInfo = reqBody.users[index];\n\n    try {\n      errors_1.assert(userInfo.localId, \"localId is missing\");\n      const uploadTime = new Date();\n      const fields = {\n        displayName: userInfo.displayName,\n        photoUrl: userInfo.photoUrl,\n        lastLoginAt: userInfo.lastLoginAt\n      };\n\n      if (userInfo.tenantId) {\n        errors_1.assert(state instanceof state_1.TenantProjectState && state.tenantId === userInfo.tenantId, \"Tenant id in userInfo does not match the tenant id in request.\");\n      }\n\n      if (state instanceof state_1.TenantProjectState) {\n        fields.tenantId = state.tenantId;\n      }\n\n      if (userInfo.passwordHash) {\n        fields.passwordHash = userInfo.passwordHash;\n        fields.salt = userInfo.salt;\n        fields.passwordUpdatedAt = uploadTime.getTime();\n      } else if (userInfo.rawPassword) {\n        fields.salt = userInfo.salt || \"fakeSalt\" + utils_1.randomId(20);\n        fields.passwordHash = hashPassword(userInfo.rawPassword, fields.salt);\n        fields.passwordUpdatedAt = uploadTime.getTime();\n      }\n\n      if (userInfo.customAttributes) {\n        validateSerializedCustomClaims(userInfo.customAttributes);\n        fields.customAttributes = userInfo.customAttributes;\n      }\n\n      if (userInfo.providerUserInfo) {\n        fields.providerUserInfo = [];\n\n        for (const providerUserInfo of userInfo.providerUserInfo) {\n          const {\n            providerId,\n            rawId,\n            federatedId\n          } = providerUserInfo;\n\n          if (providerId === state_1.PROVIDER_PASSWORD || providerId === state_1.PROVIDER_PHONE) {\n            continue;\n          }\n\n          if (!rawId || !providerId) {\n            if (!federatedId) {\n              errors_1.assert(false, \"federatedId or (providerId & rawId) is required\");\n            } else {\n              errors_1.assert(false, \"((Parsing federatedId is not implemented in Auth Emulator; please specify providerId AND rawId as a workaround.))\");\n            }\n          }\n\n          const existingUserWithRawId = state.getUserByProviderRawId(providerId, rawId);\n          errors_1.assert(!existingUserWithRawId || existingUserWithRawId.localId === userInfo.localId, \"raw id exists in other account in database\");\n          fields.providerUserInfo.push(Object.assign(Object.assign({}, providerUserInfo), {\n            providerId,\n            rawId\n          }));\n        }\n      }\n\n      if (userInfo.phoneNumber) {\n        errors_1.assert(utils_1.isValidPhoneNumber(userInfo.phoneNumber), \"phone number format is invalid\");\n        fields.phoneNumber = userInfo.phoneNumber;\n      }\n\n      fields.validSince = utils_1.toUnixTimestamp(uploadTime).toString();\n      fields.createdAt = uploadTime.getTime().toString();\n\n      if (fields.createdAt && !isNaN(Number(userInfo.createdAt))) {\n        fields.createdAt = userInfo.createdAt;\n      }\n\n      if (userInfo.email) {\n        const email = userInfo.email;\n        errors_1.assert(utils_1.isValidEmailAddress(email), \"email is invalid\");\n        const existingUserWithEmail = state.getUserByEmail(email);\n        errors_1.assert(!existingUserWithEmail || existingUserWithEmail.localId === userInfo.localId, reqBody.sanityCheck && state.oneAccountPerEmail ? \"email exists in other account in database\" : `((Auth Emulator does not support importing duplicate email: ${email}))`);\n        fields.email = utils_1.canonicalizeEmailAddress(email);\n      }\n\n      fields.emailVerified = !!userInfo.emailVerified;\n      fields.disabled = !!userInfo.disabled;\n\n      if (userInfo.mfaInfo) {\n        fields.mfaInfo = [];\n        errors_1.assert(fields.email, \"Second factor account requires email to be presented.\");\n        errors_1.assert(fields.emailVerified, \"Second factor account requires email to be verified.\");\n        const existingIds = new Set();\n\n        for (const enrollment of userInfo.mfaInfo) {\n          if (enrollment.mfaEnrollmentId) {\n            errors_1.assert(!existingIds.has(enrollment.mfaEnrollmentId), \"Enrollment id already exists.\");\n            existingIds.add(enrollment.mfaEnrollmentId);\n          }\n        }\n\n        for (const enrollment of userInfo.mfaInfo) {\n          enrollment.mfaEnrollmentId = enrollment.mfaEnrollmentId || newRandomId(28, existingIds);\n          enrollment.enrolledAt = enrollment.enrolledAt || new Date().toISOString();\n          errors_1.assert(enrollment.phoneInfo, \"Second factor not supported.\");\n          errors_1.assert(utils_1.isValidPhoneNumber(enrollment.phoneInfo), \"Phone number format is invalid\");\n          enrollment.unobfuscatedPhoneInfo = enrollment.phoneInfo;\n          fields.mfaInfo.push(enrollment);\n        }\n      }\n\n      if (state.getUserByLocalId(userInfo.localId)) {\n        errors_1.assert(reqBody.allowOverwrite, \"localId belongs to an existing account - can not overwrite.\");\n      }\n\n      state.overwriteUserWithLocalId(userInfo.localId, fields);\n    } catch (e) {\n      if (e instanceof errors_1.BadRequestError) {\n        let message = e.message;\n\n        if (message === \"INVALID_CLAIMS\") {\n          message = \"Invalid custom claims provided.\";\n        } else if (message === \"CLAIMS_TOO_LARGE\") {\n          message = \"Custom claims provided are too large.\";\n        } else if (message.startsWith(\"FORBIDDEN_CLAIM\")) {\n          message = \"Custom claims provided include a reserved claim.\";\n        }\n\n        errors.push({\n          index,\n          message\n        });\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  return {\n    kind: \"identitytoolkit#UploadAccountResponse\",\n    error: errors\n  };\n}\n\nfunction batchDelete(state, reqBody) {\n  var _a;\n\n  const errors = [];\n  const localIds = (_a = reqBody.localIds) !== null && _a !== void 0 ? _a : [];\n  errors_1.assert(localIds.length > 0 && localIds.length <= 1000, \"LOCAL_ID_LIST_EXCEEDS_LIMIT\");\n\n  for (let index = 0; index < localIds.length; index++) {\n    const localId = localIds[index];\n    const user = state.getUserByLocalId(localId);\n\n    if (!user) {\n      continue;\n    } else if (!user.disabled && !reqBody.force) {\n      errors.push({\n        index,\n        localId,\n        message: \"NOT_DISABLED : Disable the account before batch deletion.\"\n      });\n    } else {\n      state.deleteUser(user);\n    }\n  }\n\n  return {\n    errors: errors.length ? errors : undefined\n  };\n}\n\nfunction batchGet(state, reqBody, ctx) {\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  const maxResults = Math.min(Math.floor(ctx.params.query.maxResults) || 20, 1000);\n  const users = state.queryUsers({}, {\n    sortByField: \"localId\",\n    order: \"ASC\",\n    startToken: ctx.params.query.nextPageToken\n  });\n  let newPageToken = undefined;\n\n  if (maxResults >= 0 && users.length >= maxResults) {\n    users.length = maxResults;\n\n    if (users.length) {\n      newPageToken = users[users.length - 1].localId;\n    }\n  }\n\n  return {\n    kind: \"identitytoolkit#DownloadAccountResponse\",\n    users,\n    nextPageToken: newPageToken\n  };\n}\n\nfunction createAuthUri(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  const sessionId = reqBody.sessionId || utils_1.randomId(27);\n\n  if (reqBody.providerId) {\n    throw new errors_1.NotImplementedError(\"Sign-in with IDP is not yet supported.\");\n  }\n\n  errors_1.assert(reqBody.identifier, \"MISSING_IDENTIFIER\");\n  errors_1.assert(reqBody.continueUri, \"MISSING_CONTINUE_URI\");\n  errors_1.assert(utils_1.isValidEmailAddress(reqBody.identifier), \"INVALID_IDENTIFIER\");\n  const email = utils_1.canonicalizeEmailAddress(reqBody.identifier);\n  errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUri), \"INVALID_CONTINUE_URI\");\n  const allProviders = [];\n  const signinMethods = [];\n  let registered = false;\n  const users = state.getUsersByEmailOrProviderEmail(email);\n\n  if (state.oneAccountPerEmail) {\n    if (users.length) {\n      registered = true;\n      (_a = users[0].providerUserInfo) === null || _a === void 0 ? void 0 : _a.forEach(({\n        providerId\n      }) => {\n        if (providerId === state_1.PROVIDER_PASSWORD) {\n          allProviders.push(providerId);\n\n          if (users[0].passwordHash) {\n            signinMethods.push(state_1.PROVIDER_PASSWORD);\n          }\n\n          if (users[0].emailLinkSignin) {\n            signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n          }\n        } else if (providerId !== state_1.PROVIDER_PHONE) {\n          allProviders.push(providerId);\n          signinMethods.push(providerId);\n        }\n      });\n    }\n  } else {\n    const user = users.find(u => u.email);\n\n    if (user) {\n      registered = true;\n\n      if (user.passwordHash || user.emailLinkSignin) {\n        allProviders.push(state_1.PROVIDER_PASSWORD);\n\n        if (users[0].passwordHash) {\n          signinMethods.push(state_1.PROVIDER_PASSWORD);\n        }\n\n        if (users[0].emailLinkSignin) {\n          signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n        }\n      }\n    }\n  }\n\n  return {\n    kind: \"identitytoolkit#CreateAuthUriResponse\",\n    registered,\n    allProviders,\n    sessionId,\n    signinMethods\n  };\n}\n\nconst SESSION_COOKIE_MIN_VALID_DURATION = 5 * 60;\nexports.SESSION_COOKIE_MAX_VALID_DURATION = 14 * 24 * 60 * 60;\n\nfunction createSessionCookie(state, reqBody, ctx) {\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n  const validDuration = Number(reqBody.validDuration) || exports.SESSION_COOKIE_MAX_VALID_DURATION;\n  errors_1.assert(validDuration >= SESSION_COOKIE_MIN_VALID_DURATION && validDuration <= exports.SESSION_COOKIE_MAX_VALID_DURATION, \"INVALID_DURATION\");\n  const {\n    payload\n  } = parseIdToken(state, reqBody.idToken);\n  const issuedAt = utils_1.toUnixTimestamp(new Date());\n  const expiresAt = issuedAt + validDuration;\n  const sessionCookie = jsonwebtoken_1.sign(Object.assign(Object.assign({}, payload), {\n    iat: issuedAt,\n    exp: expiresAt,\n    iss: `https://session.firebase.google.com/${payload.aud}`\n  }), \"\", {\n    algorithm: \"none\"\n  });\n  return {\n    sessionCookie\n  };\n}\n\nfunction deleteAccount(state, reqBody, ctx) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  let user;\n\n  if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n    errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n    const maybeUser = state.getUserByLocalId(reqBody.localId);\n    errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n    user = maybeUser;\n  } else {\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    user = parseIdToken(state, reqBody.idToken).user;\n  }\n\n  state.deleteUser(user);\n  return {\n    kind: \"identitytoolkit#DeleteAccountResponse\"\n  };\n}\n\nfunction getProjects(state) {\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state instanceof state_1.AgentProjectState, \"UNSUPPORTED_TENANT_OPERATION\");\n  return {\n    projectId: state.projectNumber,\n    authorizedDomains: [\"localhost\"]\n  };\n}\n\nfunction getRecaptchaParams(state) {\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  return {\n    kind: \"identitytoolkit#GetRecaptchaParamResponse\",\n    recaptchaStoken: \"This-is-a-fake-token__Dont-send-this-to-the-Recaptcha-service__The-Auth-Emulator-does-not-support-Recaptcha\",\n    recaptchaSiteKey: \"Fake-key__Do-not-send-this-to-Recaptcha_\"\n  };\n}\n\nfunction queryAccounts(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n\n  if ((_a = reqBody.expression) === null || _a === void 0 ? void 0 : _a.length) {\n    throw new errors_1.NotImplementedError(\"expression is not implemented.\");\n  }\n\n  if (reqBody.returnUserInfo === false) {\n    return {\n      recordsCount: state.getUserCount().toString()\n    };\n  }\n\n  if (reqBody.limit) {\n    throw new errors_1.NotImplementedError(\"limit is not implemented.\");\n  }\n\n  reqBody.offset = reqBody.offset || \"0\";\n\n  if (reqBody.offset !== \"0\") {\n    throw new errors_1.NotImplementedError(\"offset is not implemented.\");\n  }\n\n  if (!reqBody.order || reqBody.order === \"ORDER_UNSPECIFIED\") {\n    reqBody.order = \"ASC\";\n  }\n\n  if (!reqBody.sortBy || reqBody.sortBy === \"SORT_BY_FIELD_UNSPECIFIED\") {\n    reqBody.sortBy = \"USER_ID\";\n  }\n\n  let sortByField;\n\n  if (reqBody.sortBy === \"USER_ID\") {\n    sortByField = \"localId\";\n  } else {\n    throw new errors_1.NotImplementedError(\"Only sorting by USER_ID is implemented.\");\n  }\n\n  const users = state.queryUsers({}, {\n    order: reqBody.order,\n    sortByField\n  });\n  return {\n    recordsCount: users.length.toString(),\n    userInfo: users\n  };\n}\n\nfunction resetPassword(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert(state.allowPasswordSignup, \"PASSWORD_LOGIN_DISABLED\");\n  errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n  const oob = state.validateOobCode(reqBody.oobCode);\n  errors_1.assert(oob, \"INVALID_OOB_CODE\");\n\n  if (reqBody.newPassword) {\n    errors_1.assert(oob.requestType === \"PASSWORD_RESET\", \"INVALID_OOB_CODE\");\n    errors_1.assert(reqBody.newPassword.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n    state.deleteOobCode(reqBody.oobCode);\n    let user = state.getUserByEmail(oob.email);\n    errors_1.assert(user, \"INVALID_OOB_CODE\");\n    const salt = \"fakeSalt\" + utils_1.randomId(20);\n    const passwordHash = hashPassword(reqBody.newPassword, salt);\n    user = state.updateUserByLocalId(user.localId, {\n      emailVerified: true,\n      passwordHash,\n      salt,\n      passwordUpdatedAt: Date.now(),\n      validSince: utils_1.toUnixTimestamp(new Date()).toString()\n    }, {\n      deleteProviders: (_a = user.providerUserInfo) === null || _a === void 0 ? void 0 : _a.map(info => info.providerId)\n    });\n  }\n\n  return {\n    kind: \"identitytoolkit#ResetPasswordResponse\",\n    requestType: oob.requestType,\n    email: oob.requestType === \"EMAIL_SIGNIN\" ? undefined : oob.email\n  };\n}\n\nexports.resetPassword = resetPassword;\n\nfunction sendOobCode(state, reqBody, ctx) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert(reqBody.requestType && reqBody.requestType !== \"OOB_REQ_TYPE_UNSPECIFIED\", \"MISSING_REQ_TYPE\");\n\n  if (reqBody.returnOobLink) {\n    errors_1.assert((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2, \"INSUFFICIENT_PERMISSION\");\n  }\n\n  if (reqBody.continueUrl) {\n    errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUrl), \"INVALID_CONTINUE_URI: ((expected an absolute URI with valid scheme and host))\");\n  }\n\n  let email;\n  let mode;\n\n  switch (reqBody.requestType) {\n    case \"EMAIL_SIGNIN\":\n      errors_1.assert(state.enableEmailLinkSignin, \"OPERATION_NOT_ALLOWED\");\n      mode = \"signIn\";\n      errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n      email = utils_1.canonicalizeEmailAddress(reqBody.email);\n      break;\n\n    case \"PASSWORD_RESET\":\n      mode = \"resetPassword\";\n      errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n      email = utils_1.canonicalizeEmailAddress(reqBody.email);\n      errors_1.assert(state.getUserByEmail(email), \"EMAIL_NOT_FOUND\");\n      break;\n\n    case \"VERIFY_EMAIL\":\n      mode = \"verifyEmail\";\n\n      if (reqBody.returnOobLink && !reqBody.idToken) {\n        errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n        email = utils_1.canonicalizeEmailAddress(reqBody.email);\n        const maybeUser = state.getUserByEmail(email);\n        errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n      } else {\n        const user = parseIdToken(state, reqBody.idToken || \"\").user;\n        errors_1.assert(user.email, \"MISSING_EMAIL\");\n        email = user.email;\n      }\n\n      break;\n\n    default:\n      throw new errors_1.NotImplementedError(reqBody.requestType);\n  }\n\n  if (reqBody.canHandleCodeInApp) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"canHandleCodeInApp is unsupported in Auth Emulator. All OOB operations will complete via web.\");\n  }\n\n  const url = utils_1.authEmulatorUrl(ctx.req);\n  const oobRecord = createOobRecord(state, email, url, {\n    requestType: reqBody.requestType,\n    mode,\n    continueUrl: reqBody.continueUrl\n  });\n\n  if (reqBody.returnOobLink) {\n    return {\n      kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n      email,\n      oobCode: oobRecord.oobCode,\n      oobLink: oobRecord.oobLink\n    };\n  } else {\n    logOobMessage(oobRecord);\n    return {\n      kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n      email\n    };\n  }\n}\n\nfunction sendVerificationCode(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state instanceof state_1.AgentProjectState, \"UNSUPPORTED_TENANT_OPERATION\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert(reqBody.phoneNumber && utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n  const user = state.getUserByPhoneNumber(reqBody.phoneNumber);\n  errors_1.assert(!((_a = user === null || user === void 0 ? void 0 : user.mfaInfo) === null || _a === void 0 ? void 0 : _a.length), \"UNSUPPORTED_FIRST_FACTOR : A phone number cannot be set as a first factor on an SMS based MFA user.\");\n  const {\n    sessionInfo,\n    phoneNumber,\n    code\n  } = state.createVerificationCode(reqBody.phoneNumber);\n  emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To verify the phone number ${phoneNumber}, use the code ${code}.`);\n  return {\n    sessionInfo\n  };\n}\n\nfunction setAccountInfo(state, reqBody, ctx) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  const url = utils_1.authEmulatorUrl(ctx.req);\n  return setAccountInfoImpl(state, reqBody, {\n    privileged: !!((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2),\n    emulatorUrl: url\n  });\n}\n\nfunction setAccountInfoImpl(state, reqBody, {\n  privileged = false,\n  emulatorUrl = undefined\n} = {}) {\n  var _a, _b;\n\n  const unimplementedFields = [\"provider\", \"upgradeToFederatedLogin\", \"linkProviderUserInfo\"];\n\n  for (const field of unimplementedFields) {\n    if (field in reqBody) {\n      throw new errors_1.NotImplementedError(`${field} is not implemented yet.`);\n    }\n  }\n\n  if (!privileged) {\n    errors_1.assert(reqBody.idToken || reqBody.oobCode, \"INVALID_REQ_TYPE : Unsupported request parameters.\");\n    errors_1.assert(reqBody.customAttributes == null, \"INSUFFICIENT_PERMISSION\");\n  } else {\n    errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n  }\n\n  if (reqBody.customAttributes) {\n    validateSerializedCustomClaims(reqBody.customAttributes);\n  }\n\n  reqBody.deleteAttribute = reqBody.deleteAttribute || [];\n\n  for (const attr of reqBody.deleteAttribute) {\n    if (attr === \"PROVIDER\" || attr === \"RAW_USER_INFO\") {\n      throw new errors_1.NotImplementedError(`deleteAttribute: ${attr}`);\n    }\n  }\n\n  const updates = {};\n  let user;\n  let signInProvider;\n  let isEmailUpdate = false;\n\n  if (reqBody.oobCode) {\n    const oob = state.validateOobCode(reqBody.oobCode);\n    errors_1.assert(oob, \"INVALID_OOB_CODE\");\n\n    switch (oob.requestType) {\n      case \"VERIFY_EMAIL\":\n        {\n          state.deleteOobCode(reqBody.oobCode);\n          signInProvider = state_1.PROVIDER_PASSWORD;\n          const maybeUser = state.getUserByEmail(oob.email);\n          errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n          user = maybeUser;\n          updates.emailVerified = true;\n\n          if (oob.email !== user.email) {\n            updates.email = oob.email;\n          }\n\n          break;\n        }\n\n      case \"RECOVER_EMAIL\":\n        {\n          state.deleteOobCode(reqBody.oobCode);\n          const maybeUser = state.getUserByInitialEmail(oob.email);\n          errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n          errors_1.assert(!state.getUserByEmail(oob.email), \"EMAIL_EXISTS\");\n          user = maybeUser;\n\n          if (oob.email !== user.email) {\n            updates.email = oob.email;\n            updates.emailVerified = true;\n          }\n\n          break;\n        }\n\n      default:\n        throw new errors_1.NotImplementedError(oob.requestType);\n    }\n  } else {\n    if (reqBody.idToken) {\n      ({\n        user,\n        signInProvider\n      } = parseIdToken(state, reqBody.idToken));\n      errors_1.assert(reqBody.disableUser == null, \"OPERATION_NOT_ALLOWED\");\n    } else {\n      errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n      const maybeUser = state.getUserByLocalId(reqBody.localId);\n      errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n      user = maybeUser;\n    }\n\n    if (reqBody.email) {\n      errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n      const newEmail = utils_1.canonicalizeEmailAddress(reqBody.email);\n\n      if (newEmail !== user.email) {\n        errors_1.assert(!state.getUserByEmail(newEmail), \"EMAIL_EXISTS\");\n        updates.email = newEmail;\n        updates.emailVerified = false;\n        isEmailUpdate = true;\n\n        if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.email && !user.initialEmail) {\n          updates.initialEmail = user.email;\n        }\n      }\n    }\n\n    if (reqBody.password) {\n      errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n      updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n      updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n      updates.passwordUpdatedAt = Date.now();\n      signInProvider = state_1.PROVIDER_PASSWORD;\n    }\n\n    if (reqBody.password || reqBody.validSince || updates.email) {\n      updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n    }\n\n    if (reqBody.mfa) {\n      if (reqBody.mfa.enrollments && reqBody.mfa.enrollments.length > 0) {\n        updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfa.enrollments);\n      } else {\n        updates.mfaInfo = undefined;\n      }\n    }\n\n    const fieldsToCopy = [\"displayName\", \"photoUrl\"];\n\n    if (privileged) {\n      if (reqBody.disableUser != null) {\n        updates.disabled = reqBody.disableUser;\n      }\n\n      if (reqBody.phoneNumber && reqBody.phoneNumber !== user.phoneNumber) {\n        errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n        errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n        updates.phoneNumber = reqBody.phoneNumber;\n      }\n\n      fieldsToCopy.push(\"emailVerified\", \"customAttributes\", \"createdAt\", \"lastLoginAt\", \"validSince\");\n    }\n\n    for (const field of fieldsToCopy) {\n      if (reqBody[field] != null) {\n        utils_1.mirrorFieldTo(updates, field, reqBody);\n      }\n    }\n\n    for (const attr of reqBody.deleteAttribute) {\n      switch (attr) {\n        case \"USER_ATTRIBUTE_NAME_UNSPECIFIED\":\n          continue;\n\n        case \"DISPLAY_NAME\":\n          updates.displayName = undefined;\n          break;\n\n        case \"PHOTO_URL\":\n          updates.photoUrl = undefined;\n          break;\n\n        case \"PASSWORD\":\n          updates.passwordHash = undefined;\n          updates.salt = undefined;\n          break;\n\n        case \"EMAIL\":\n          updates.email = undefined;\n          updates.emailVerified = undefined;\n          updates.emailLinkSignin = undefined;\n          break;\n      }\n    }\n\n    if ((_a = reqBody.deleteProvider) === null || _a === void 0 ? void 0 : _a.includes(state_1.PROVIDER_PASSWORD)) {\n      updates.email = undefined;\n      updates.emailVerified = undefined;\n      updates.emailLinkSignin = undefined;\n      updates.passwordHash = undefined;\n      updates.salt = undefined;\n    }\n\n    if ((_b = reqBody.deleteProvider) === null || _b === void 0 ? void 0 : _b.includes(state_1.PROVIDER_PHONE)) {\n      updates.phoneNumber = undefined;\n    }\n  }\n\n  user = state.updateUserByLocalId(user.localId, updates, {\n    deleteProviders: reqBody.deleteProvider\n  });\n\n  if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.initialEmail && isEmailUpdate) {\n    if (!emulatorUrl) {\n      throw new Error(\"Internal assertion error: missing emulatorUrl param\");\n    }\n\n    sendOobForEmailReset(state, user.initialEmail, emulatorUrl);\n  }\n\n  return redactPasswordHash(Object.assign({\n    kind: \"identitytoolkit#SetAccountInfoResponse\",\n    localId: user.localId,\n    emailVerified: user.emailVerified,\n    providerUserInfo: user.providerUserInfo,\n    email: user.email,\n    displayName: user.displayName,\n    photoUrl: user.photoUrl,\n    passwordHash: user.passwordHash\n  }, updates.validSince && signInProvider ? issueTokens(state, user, signInProvider) : {}));\n}\n\nexports.setAccountInfoImpl = setAccountInfoImpl;\n\nfunction sendOobForEmailReset(state, initialEmail, url) {\n  const oobRecord = createOobRecord(state, initialEmail, url, {\n    requestType: \"RECOVER_EMAIL\",\n    mode: \"recoverEmail\"\n  });\n  logOobMessage(oobRecord);\n}\n\nfunction createOobRecord(state, email, url, params) {\n  const oobRecord = state.createOob(email, params.requestType, oobCode => {\n    url.pathname = \"/emulator/action\";\n    url.searchParams.set(\"mode\", params.mode);\n    url.searchParams.set(\"lang\", \"en\");\n    url.searchParams.set(\"oobCode\", oobCode);\n    url.searchParams.set(\"apiKey\", \"fake-api-key\");\n\n    if (params.continueUrl) {\n      url.searchParams.set(\"continueUrl\", params.continueUrl);\n    }\n\n    if (state instanceof state_1.TenantProjectState) {\n      url.searchParams.set(\"tenantId\", state.tenantId);\n    }\n\n    return url.toString();\n  });\n  return oobRecord;\n}\n\nfunction logOobMessage(oobRecord) {\n  const oobLink = oobRecord.oobLink;\n  const email = oobRecord.email;\n  let maybeMessage;\n\n  switch (oobRecord.requestType) {\n    case \"EMAIL_SIGNIN\":\n      maybeMessage = `To sign in as ${email}, follow this link: ${oobLink}`;\n      break;\n\n    case \"PASSWORD_RESET\":\n      maybeMessage = `To reset the password for ${email}, follow this link: ${oobLink}&newPassword=NEW_PASSWORD_HERE`;\n      break;\n\n    case \"VERIFY_EMAIL\":\n      maybeMessage = `To verify the email address ${email}, follow this link: ${oobLink}`;\n      break;\n\n    case \"RECOVER_EMAIL\":\n      maybeMessage = `To reset your email address to ${email}, follow this link: ${oobLink}`;\n      break;\n  }\n\n  if (maybeMessage) {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", maybeMessage);\n  }\n}\n\nfunction signInWithCustomToken(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(reqBody.token, \"MISSING_CUSTOM_TOKEN\");\n  let payload;\n\n  if (reqBody.token.startsWith(\"{\")) {\n    try {\n      payload = JSON.parse(reqBody.token);\n    } catch (_b) {\n      throw new errors_1.BadRequestError(\"INVALID_CUSTOM_TOKEN : ((Auth Emulator only accepts strict JSON or JWTs as fake custom tokens.))\");\n    }\n  } else {\n    const decoded = jsonwebtoken_1.decode(reqBody.token, {\n      complete: true\n    });\n\n    if (state instanceof state_1.TenantProjectState) {\n      errors_1.assert((decoded === null || decoded === void 0 ? void 0 : decoded.payload.tenant_id) === state.tenantId, \"TENANT_ID_MISMATCH\");\n    }\n\n    errors_1.assert(decoded, \"INVALID_CUSTOM_TOKEN : Invalid assertion format\");\n\n    if (decoded.header.alg !== \"none\") {\n      emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed custom token. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n    }\n\n    errors_1.assert(decoded.payload.aud === exports.CUSTOM_TOKEN_AUDIENCE, `INVALID_CUSTOM_TOKEN : ((Invalid aud (audience): ${decoded.payload.aud} ` + \"Note: Firebase ID Tokens / third-party tokens cannot be used with signInWithCustomToken.))\");\n    payload = decoded.payload;\n  }\n\n  const localId = (_a = coercePrimitiveToString(payload.uid)) !== null && _a !== void 0 ? _a : coercePrimitiveToString(payload.user_id);\n  errors_1.assert(localId, \"MISSING_IDENTIFIER\");\n  let extraClaims = {};\n\n  if (\"claims\" in payload) {\n    validateCustomClaims(payload.claims);\n    extraClaims = payload.claims;\n  }\n\n  let user = state.getUserByLocalId(localId);\n  const isNewUser = state.usageMode === state_1.UsageMode.PASSTHROUGH ? false : !user;\n  const updates = {\n    customAuth: true,\n    lastLoginAt: Date.now().toString(),\n    tenantId: state instanceof state_1.TenantProjectState ? state.tenantId : undefined\n  };\n\n  if (user) {\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    user = state.updateUserByLocalId(localId, updates);\n  } else {\n    user = state.createUserWithLocalId(localId, updates);\n\n    if (!user) {\n      throw new Error(`Internal assertion error: trying to create duplicate localId: ${localId}`);\n    }\n  }\n\n  return Object.assign({\n    kind: \"identitytoolkit#VerifyCustomTokenResponse\",\n    isNewUser\n  }, issueTokens(state, user, state_1.PROVIDER_CUSTOM, {\n    extraClaims\n  }));\n}\n\nfunction signInWithEmailLink(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.enableEmailLinkSignin, \"OPERATION_NOT_ALLOWED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n  errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n  const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n  errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n  const oob = state.validateOobCode(reqBody.oobCode);\n  errors_1.assert(oob && oob.requestType === \"EMAIL_SIGNIN\", \"INVALID_OOB_CODE\");\n  errors_1.assert(email === oob.email, \"INVALID_EMAIL : The email provided does not match the sign-in email address.\");\n  state.deleteOobCode(reqBody.oobCode);\n  const updates = {\n    email,\n    emailVerified: true,\n    emailLinkSignin: true\n  };\n\n  if (state instanceof state_1.TenantProjectState) {\n    updates.tenantId = state.tenantId;\n  }\n\n  let user = state.getUserByEmail(email);\n  const isNewUser = !user && !userFromIdToken;\n\n  if (!user) {\n    if (userFromIdToken) {\n      user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n    } else {\n      user = state.createUser(updates);\n    }\n  } else {\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    errors_1.assert(!userFromIdToken || userFromIdToken.localId === user.localId, \"EMAIL_EXISTS\");\n    user = state.updateUserByLocalId(user.localId, updates);\n  }\n\n  const response = {\n    kind: \"identitytoolkit#EmailLinkSigninResponse\",\n    email,\n    localId: user.localId,\n    isNewUser\n  };\n\n  if ((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = user.mfaInfo) === null || _a === void 0 ? void 0 : _a.length)) {\n    return Object.assign(Object.assign({}, response), mfaPending(state, user, state_1.PROVIDER_PASSWORD));\n  } else {\n    user = state.updateUserByLocalId(user.localId, {\n      lastLoginAt: Date.now().toString()\n    });\n    return Object.assign(Object.assign({}, response), issueTokens(state, user, state_1.PROVIDER_PASSWORD));\n  }\n}\n\nfunction signInWithIdp(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n\n  if (reqBody.returnRefreshToken) {\n    throw new errors_1.NotImplementedError(\"returnRefreshToken is not implemented yet.\");\n  }\n\n  if (reqBody.pendingIdToken) {\n    throw new errors_1.NotImplementedError(\"pendingIdToken is not implemented yet.\");\n  }\n\n  const normalizedUri = getNormalizedUri(reqBody);\n  const providerId = (_a = normalizedUri.searchParams.get(\"providerId\")) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n  errors_1.assert(providerId, `INVALID_CREDENTIAL_OR_PROVIDER_ID : Invalid IdP response/credential: ${normalizedUri.toString()}`);\n  const oauthIdToken = normalizedUri.searchParams.get(\"id_token\") || undefined;\n  const oauthAccessToken = normalizedUri.searchParams.get(\"access_token\") || undefined;\n  const claims = parseClaims(oauthIdToken) || parseClaims(oauthAccessToken);\n\n  if (!claims) {\n    if (oauthIdToken) {\n      throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${oauthIdToken} ((Auth Emulator only accepts strict JSON or JWTs as fake id_tokens.))`);\n    } else if (oauthAccessToken) {\n      if (providerId === \"google.com\" || providerId === \"apple.com\") {\n        throw new errors_1.NotImplementedError(`The Auth Emulator only support sign-in with ${providerId} using id_token, not access_token. Please update your code to use id_token.`);\n      } else {\n        throw new errors_1.NotImplementedError(`The Auth Emulator does not support ${providerId} sign-in with credentials.`);\n      }\n    } else {\n      throw new errors_1.NotImplementedError(\"The Auth Emulator only supports sign-in with credentials (id_token required).\");\n    }\n  }\n\n  let {\n    response,\n    rawId\n  } = fakeFetchUserInfoFromIdp(providerId, claims);\n  response.oauthAccessToken = oauthAccessToken || `FirebaseAuthEmulatorFakeAccessToken_${providerId}`;\n  response.oauthIdToken = oauthIdToken;\n  const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n  const userMatchingProvider = state.getUserByProviderRawId(providerId, rawId);\n  let accountUpdates;\n\n  try {\n    if (userFromIdToken) {\n      errors_1.assert(!userMatchingProvider, \"FEDERATED_USER_ID_ALREADY_LINKED\");\n      ({\n        accountUpdates,\n        response\n      } = handleLinkIdp(state, response, userFromIdToken));\n    } else if (state.oneAccountPerEmail) {\n      const userMatchingEmail = response.email ? state.getUserByEmail(response.email) : undefined;\n      ({\n        accountUpdates,\n        response\n      } = handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail));\n    } else {\n      ({\n        accountUpdates,\n        response\n      } = handleIdpSigninEmailNotRequired(response, userMatchingProvider));\n    }\n  } catch (err) {\n    if (reqBody.returnIdpCredential && err instanceof errors_1.BadRequestError) {\n      response.errorMessage = err.message;\n      return response;\n    } else {\n      throw err;\n    }\n  }\n\n  if (response.needConfirmation) {\n    return response;\n  }\n\n  const providerUserInfo = {\n    providerId,\n    rawId,\n    federatedId: rawId,\n    displayName: response.displayName,\n    photoUrl: response.photoUrl,\n    email: response.email,\n    screenName: response.screenName\n  };\n  let user;\n\n  if (response.isNewUser) {\n    user = state.createUser(Object.assign(Object.assign({}, accountUpdates.fields), {\n      lastLoginAt: Date.now().toString(),\n      providerUserInfo: [providerUserInfo],\n      tenantId: state instanceof state_1.TenantProjectState ? state.tenantId : undefined\n    }));\n    response.localId = user.localId;\n  } else {\n    if (!response.localId) {\n      throw new Error(\"Internal assertion error: localId not set for exising user.\");\n    }\n\n    user = state.updateUserByLocalId(response.localId, Object.assign({}, accountUpdates.fields), {\n      upsertProviders: [providerUserInfo]\n    });\n  }\n\n  if (user.email === response.email) {\n    response.emailVerified = user.emailVerified;\n  }\n\n  if (state instanceof state_1.TenantProjectState) {\n    response.tenantId = state.tenantId;\n  }\n\n  if ((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.length)) {\n    return Object.assign(Object.assign({}, response), mfaPending(state, user, providerId));\n  } else {\n    user = state.updateUserByLocalId(user.localId, {\n      lastLoginAt: Date.now().toString()\n    });\n    return Object.assign(Object.assign({}, response), issueTokens(state, user, providerId));\n  }\n}\n\nfunction signInWithPassword(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state.allowPasswordSignup, \"PASSWORD_LOGIN_DISABLED\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n  errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n\n  if (reqBody.captchaResponse || reqBody.captchaChallenge) {\n    throw new errors_1.NotImplementedError(\"captcha unimplemented\");\n  }\n\n  if (reqBody.idToken || reqBody.pendingIdToken) {\n    throw new errors_1.NotImplementedError(\"idToken / pendingIdToken is no longer in use and unsupported by the Auth Emulator.\");\n  }\n\n  const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n  let user = state.getUserByEmail(email);\n  errors_1.assert(user, \"EMAIL_NOT_FOUND\");\n  errors_1.assert(!user.disabled, \"USER_DISABLED\");\n  errors_1.assert(user.passwordHash && user.salt, \"INVALID_PASSWORD\");\n  errors_1.assert(user.passwordHash === hashPassword(reqBody.password, user.salt), \"INVALID_PASSWORD\");\n  const response = {\n    kind: \"identitytoolkit#VerifyPasswordResponse\",\n    registered: true,\n    localId: user.localId,\n    email\n  };\n\n  if ((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = user.mfaInfo) === null || _a === void 0 ? void 0 : _a.length)) {\n    return Object.assign(Object.assign({}, response), mfaPending(state, user, state_1.PROVIDER_PASSWORD));\n  } else {\n    user = state.updateUserByLocalId(user.localId, {\n      lastLoginAt: Date.now().toString()\n    });\n    return Object.assign(Object.assign({}, response), issueTokens(state, user, state_1.PROVIDER_PASSWORD));\n  }\n}\n\nfunction signInWithPhoneNumber(state, reqBody) {\n  var _a;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(state instanceof state_1.AgentProjectState, \"UNSUPPORTED_TENANT_OPERATION\");\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  let phoneNumber;\n\n  if (reqBody.temporaryProof) {\n    errors_1.assert(reqBody.phoneNumber, \"MISSING_PHONE_NUMBER\");\n    const proof = state.validateTemporaryProof(reqBody.temporaryProof, reqBody.phoneNumber);\n    errors_1.assert(proof, \"INVALID_TEMPORARY_PROOF\");\n    ({\n      phoneNumber\n    } = proof);\n  } else {\n    errors_1.assert(reqBody.sessionInfo, \"MISSING_SESSION_INFO\");\n    errors_1.assert(reqBody.code, \"MISSING_CODE\");\n    phoneNumber = verifyPhoneNumber(state, reqBody.sessionInfo, reqBody.code);\n  }\n\n  let user = state.getUserByPhoneNumber(phoneNumber);\n  let isNewUser = false;\n  const updates = {\n    phoneNumber,\n    lastLoginAt: Date.now().toString()\n  };\n  const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n\n  if (!user) {\n    if (userFromIdToken) {\n      errors_1.assert(!((_a = userFromIdToken.mfaInfo) === null || _a === void 0 ? void 0 : _a.length), \"UNSUPPORTED_FIRST_FACTOR : A phone number cannot be set as a first factor on an SMS based MFA user.\");\n      user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n    } else {\n      isNewUser = true;\n      user = state.createUser(updates);\n    }\n  } else {\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n\n    if (userFromIdToken && userFromIdToken.localId !== user.localId) {\n      if (!reqBody.temporaryProof) {\n        return Object.assign({}, state.createTemporaryProof(phoneNumber));\n      }\n\n      throw new errors_1.BadRequestError(\"PHONE_NUMBER_EXISTS\");\n    }\n\n    user = state.updateUserByLocalId(user.localId, updates);\n  }\n\n  const tokens = issueTokens(state, user, state_1.PROVIDER_PHONE);\n  return Object.assign({\n    isNewUser,\n    phoneNumber,\n    localId: user.localId\n  }, tokens);\n}\n\nfunction grantToken(state, reqBody) {\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  errors_1.assert(reqBody.grantType, \"MISSING_GRANT_TYPE\");\n  errors_1.assert(reqBody.grantType === \"refresh_token\", \"INVALID_GRANT_TYPE\");\n  errors_1.assert(reqBody.refreshToken, \"MISSING_REFRESH_TOKEN\");\n  const refreshTokenRecord = state.validateRefreshToken(reqBody.refreshToken);\n  errors_1.assert(refreshTokenRecord, \"INVALID_REFRESH_TOKEN\");\n  errors_1.assert(!refreshTokenRecord.user.disabled, \"USER_DISABLED\");\n  const tokens = issueTokens(state, refreshTokenRecord.user, refreshTokenRecord.provider, {\n    extraClaims: refreshTokenRecord.extraClaims,\n    secondFactor: refreshTokenRecord.secondFactor\n  });\n  return {\n    id_token: tokens.idToken,\n    access_token: tokens.idToken,\n    expires_in: tokens.expiresIn,\n    refresh_token: tokens.refreshToken,\n    token_type: \"Bearer\",\n    user_id: refreshTokenRecord.user.localId,\n    project_id: state.projectNumber\n  };\n}\n\nfunction deleteAllAccountsInProject(state) {\n  state.deleteAllAccounts();\n  return {};\n}\n\nfunction getEmulatorProjectConfig(state) {\n  return {\n    signIn: {\n      allowDuplicateEmails: !state.oneAccountPerEmail\n    },\n    usageMode: state.usageMode\n  };\n}\n\nfunction updateEmulatorProjectConfig(state, reqBody) {\n  var _a;\n\n  const allowDuplicateEmails = (_a = reqBody.signIn) === null || _a === void 0 ? void 0 : _a.allowDuplicateEmails;\n\n  if (allowDuplicateEmails != null) {\n    errors_1.assert(state instanceof state_1.AgentProjectState, \"((Only top level projects can set oneAccountPerEmail.))\");\n    state.oneAccountPerEmail = !allowDuplicateEmails;\n  }\n\n  const usageMode = reqBody.usageMode;\n\n  if (usageMode != null) {\n    errors_1.assert(state instanceof state_1.AgentProjectState, \"((Only top level projects can set usageMode.))\");\n\n    switch (usageMode) {\n      case \"PASSTHROUGH\":\n        errors_1.assert(state.getUserCount() === 0, \"Users are present, unable to set passthrough mode\");\n        state.usageMode = state_1.UsageMode.PASSTHROUGH;\n        break;\n\n      case \"DEFAULT\":\n        state.usageMode = state_1.UsageMode.DEFAULT;\n        break;\n\n      default:\n        throw new errors_1.BadRequestError(\"Invalid usage mode provided\");\n    }\n  }\n\n  return getEmulatorProjectConfig(state);\n}\n\nfunction listOobCodesInProject(state) {\n  return {\n    oobCodes: [...state.listOobCodes()]\n  };\n}\n\nfunction listVerificationCodesInProject(state) {\n  return {\n    verificationCodes: [...state.listVerificationCodes()]\n  };\n}\n\nfunction mfaEnrollmentStart(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n  errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n  const {\n    user,\n    signInProvider\n  } = parseIdToken(state, reqBody.idToken);\n  errors_1.assert(!MFA_INELIGIBLE_PROVIDER.has(signInProvider), \"UNSUPPORTED_FIRST_FACTOR : MFA is not available for the given first factor.\");\n  errors_1.assert(user.emailVerified, \"UNVERIFIED_EMAIL : Need to verify email first before enrolling second factors.\");\n  errors_1.assert(reqBody.phoneEnrollmentInfo, \"INVALID_ARGUMENT : ((Missing phoneEnrollmentInfo.))\");\n  const phoneNumber = reqBody.phoneEnrollmentInfo.phoneNumber;\n  errors_1.assert(phoneNumber && utils_1.isValidPhoneNumber(phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n  errors_1.assert(!((_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.some(enrollment => enrollment.unobfuscatedPhoneInfo === phoneNumber)), \"SECOND_FACTOR_EXISTS : Phone number already enrolled as second factor for this account.\");\n  const {\n    sessionInfo,\n    code\n  } = state.createVerificationCode(phoneNumber);\n  emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To enroll MFA with ${phoneNumber}, use the code ${code}.`);\n  return {\n    phoneSessionInfo: {\n      sessionInfo\n    }\n  };\n}\n\nfunction mfaEnrollmentFinalize(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n  errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n  let {\n    user,\n    signInProvider\n  } = parseIdToken(state, reqBody.idToken);\n  errors_1.assert(!MFA_INELIGIBLE_PROVIDER.has(signInProvider), \"UNSUPPORTED_FIRST_FACTOR : MFA is not available for the given first factor.\");\n  errors_1.assert(reqBody.phoneVerificationInfo, \"INVALID_ARGUMENT : ((Missing phoneVerificationInfo.))\");\n\n  if (reqBody.phoneVerificationInfo.androidVerificationProof) {\n    throw new errors_1.NotImplementedError(\"androidVerificationProof is unsupported!\");\n  }\n\n  const {\n    code,\n    sessionInfo\n  } = reqBody.phoneVerificationInfo;\n  errors_1.assert(code, \"MISSING_CODE\");\n  errors_1.assert(sessionInfo, \"MISSING_SESSION_INFO\");\n  const phoneNumber = verifyPhoneNumber(state, sessionInfo, code);\n  errors_1.assert(!((_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.some(enrollment => enrollment.unobfuscatedPhoneInfo === phoneNumber)), \"SECOND_FACTOR_EXISTS : Phone number already enrolled as second factor for this account.\");\n  const existingFactors = user.mfaInfo || [];\n  const existingIds = new Set();\n\n  for (const {\n    mfaEnrollmentId\n  } of existingFactors) {\n    if (mfaEnrollmentId) {\n      existingIds.add(mfaEnrollmentId);\n    }\n  }\n\n  const enrollment = {\n    displayName: reqBody.displayName,\n    enrolledAt: new Date().toISOString(),\n    mfaEnrollmentId: newRandomId(28, existingIds),\n    phoneInfo: phoneNumber,\n    unobfuscatedPhoneInfo: phoneNumber\n  };\n  user = state.updateUserByLocalId(user.localId, {\n    mfaInfo: [...existingFactors, enrollment]\n  });\n  const {\n    idToken,\n    refreshToken\n  } = issueTokens(state, user, signInProvider, {\n    secondFactor: {\n      identifier: enrollment.mfaEnrollmentId,\n      provider: state_1.PROVIDER_PHONE\n    }\n  });\n  return {\n    idToken,\n    refreshToken\n  };\n}\n\nfunction mfaEnrollmentWithdraw(state, reqBody) {\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n  let {\n    user,\n    signInProvider\n  } = parseIdToken(state, reqBody.idToken);\n  errors_1.assert(user.mfaInfo, \"MFA_ENROLLMENT_NOT_FOUND\");\n  const updatedList = user.mfaInfo.filter(enrollment => enrollment.mfaEnrollmentId !== reqBody.mfaEnrollmentId);\n  errors_1.assert(updatedList.length < user.mfaInfo.length, \"MFA_ENROLLMENT_NOT_FOUND\");\n  user = state.updateUserByLocalId(user.localId, {\n    mfaInfo: updatedList\n  });\n  return Object.assign({}, issueTokens(state, user, signInProvider));\n}\n\nfunction mfaSignInStart(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n  errors_1.assert(reqBody.mfaPendingCredential, \"MISSING_MFA_PENDING_CREDENTIAL : Request does not have MFA pending credential.\");\n  errors_1.assert(reqBody.mfaEnrollmentId, \"MISSING_MFA_ENROLLMENT_ID : No second factor identifier is provided.\");\n  const {\n    user\n  } = parsePendingCredential(state, reqBody.mfaPendingCredential);\n  const enrollment = (_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.find(factor => factor.mfaEnrollmentId === reqBody.mfaEnrollmentId);\n  errors_1.assert(enrollment, \"MFA_ENROLLMENT_NOT_FOUND\");\n  const phoneNumber = enrollment.unobfuscatedPhoneInfo;\n  errors_1.assert(phoneNumber, \"INVALID_ARGUMENT : MFA provider not supported!\");\n  const {\n    sessionInfo,\n    code\n  } = state.createVerificationCode(phoneNumber);\n  emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To sign in with MFA using ${phoneNumber}, use the code ${code}.`);\n  return {\n    phoneResponseInfo: {\n      sessionInfo\n    }\n  };\n}\n\nfunction mfaSignInFinalize(state, reqBody) {\n  var _a, _b;\n\n  errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n  errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n  errors_1.assert(reqBody.mfaPendingCredential, \"MISSING_CREDENTIAL : Please set MFA Pending Credential.\");\n  errors_1.assert(reqBody.phoneVerificationInfo, \"INVALID_ARGUMENT : MFA provider not supported!\");\n\n  if (reqBody.phoneVerificationInfo.androidVerificationProof) {\n    throw new errors_1.NotImplementedError(\"androidVerificationProof is unsupported!\");\n  }\n\n  const {\n    code,\n    sessionInfo\n  } = reqBody.phoneVerificationInfo;\n  errors_1.assert(code, \"MISSING_CODE\");\n  errors_1.assert(sessionInfo, \"MISSING_SESSION_INFO\");\n  const phoneNumber = verifyPhoneNumber(state, sessionInfo, code);\n  let {\n    user,\n    signInProvider\n  } = parsePendingCredential(state, reqBody.mfaPendingCredential);\n  const enrollment = (_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.find(enrollment => enrollment.unobfuscatedPhoneInfo == phoneNumber);\n  errors_1.assert(enrollment && enrollment.mfaEnrollmentId, \"MFA_ENROLLMENT_NOT_FOUND\");\n  user = state.updateUserByLocalId(user.localId, {\n    lastLoginAt: Date.now().toString()\n  });\n  errors_1.assert(!user.disabled, \"USER_DISABLED\");\n  const {\n    idToken,\n    refreshToken\n  } = issueTokens(state, user, signInProvider, {\n    secondFactor: {\n      identifier: enrollment.mfaEnrollmentId,\n      provider: state_1.PROVIDER_PHONE\n    }\n  });\n  return {\n    idToken,\n    refreshToken\n  };\n}\n\nfunction coercePrimitiveToString(value) {\n  switch (typeof value) {\n    case \"string\":\n      return value;\n\n    case \"number\":\n    case \"boolean\":\n      return value.toString();\n\n    default:\n      return undefined;\n  }\n}\n\nfunction redactPasswordHash(user) {\n  return user;\n}\n\nfunction hashPassword(password, salt) {\n  return `fakeHash:salt=${salt}:password=${password}`;\n}\n\nfunction issueTokens(state, user, signInProvider, {\n  extraClaims,\n  secondFactor\n} = {}) {\n  user = state.updateUserByLocalId(user.localId, {\n    lastRefreshAt: new Date().toISOString()\n  });\n  const usageMode = state.usageMode === state_1.UsageMode.PASSTHROUGH ? \"passthrough\" : undefined;\n  const tenantId = state instanceof state_1.TenantProjectState ? state.tenantId : undefined;\n  const expiresInSeconds = 60 * 60;\n  const idToken = generateJwt(user, {\n    projectId: state.projectId,\n    signInProvider,\n    expiresInSeconds,\n    extraClaims,\n    secondFactor,\n    usageMode,\n    tenantId\n  });\n  const refreshToken = state.usageMode === state_1.UsageMode.DEFAULT ? state.createRefreshTokenFor(user, signInProvider, {\n    extraClaims,\n    secondFactor\n  }) : undefined;\n  return {\n    idToken,\n    refreshToken,\n    expiresIn: expiresInSeconds.toString()\n  };\n}\n\nfunction parseIdToken(state, idToken) {\n  errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n  const decoded = jsonwebtoken_1.decode(idToken, {\n    complete: true\n  });\n  errors_1.assert(decoded, \"INVALID_ID_TOKEN\");\n\n  if (decoded.header.alg !== \"none\") {\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed JWT. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n  }\n\n  if (decoded.payload.firebase.tenant) {\n    errors_1.assert(state instanceof state_1.TenantProjectState, \"((Parsed token that belongs to tenant in a non-tenant project.))\");\n    errors_1.assert(decoded.payload.firebase.tenant === state.tenantId, \"TENANT_ID_MISMATCH\");\n  }\n\n  const user = state.getUserByLocalId(decoded.payload.user_id);\n  errors_1.assert(user, \"USER_NOT_FOUND\");\n  errors_1.assert(!user.validSince || decoded.payload.iat >= Number(user.validSince), \"TOKEN_EXPIRED\");\n  errors_1.assert(!user.disabled, \"USER_DISABLED\");\n  const signInProvider = decoded.payload.firebase.sign_in_provider;\n  return {\n    user,\n    signInProvider,\n    payload: decoded.payload\n  };\n}\n\nfunction generateJwt(user, {\n  projectId,\n  signInProvider,\n  expiresInSeconds,\n  extraClaims = {},\n  secondFactor,\n  usageMode,\n  tenantId\n}) {\n  const identities = {};\n\n  if (user.email) {\n    identities[\"email\"] = [user.email];\n  }\n\n  if (user.providerUserInfo) {\n    for (const providerInfo of user.providerUserInfo) {\n      if (providerInfo.providerId && providerInfo.providerId !== state_1.PROVIDER_PASSWORD && providerInfo.rawId) {\n        const ids = identities[providerInfo.providerId] || [];\n        ids.push(providerInfo.rawId);\n        identities[providerInfo.providerId] = ids;\n      }\n    }\n  }\n\n  const customAttributes = JSON.parse(user.customAttributes || \"{}\");\n  const customPayloadFields = Object.assign(Object.assign(Object.assign({\n    name: user.displayName,\n    picture: user.photoUrl\n  }, customAttributes), extraClaims), {\n    email: user.email,\n    email_verified: user.emailVerified,\n    phone_number: user.phoneNumber,\n    provider_id: signInProvider === \"anonymous\" ? signInProvider : undefined,\n    auth_time: utils_1.toUnixTimestamp(getAuthTime(user)),\n    user_id: user.localId,\n    firebase: {\n      identities,\n      sign_in_provider: signInProvider,\n      second_factor_identifier: secondFactor === null || secondFactor === void 0 ? void 0 : secondFactor.identifier,\n      sign_in_second_factor: secondFactor === null || secondFactor === void 0 ? void 0 : secondFactor.provider,\n      usage_mode: usageMode,\n      tenant: tenantId\n    }\n  });\n  const jwtStr = jsonwebtoken_1.sign(customPayloadFields, \"\", {\n    algorithm: \"none\",\n    expiresIn: expiresInSeconds,\n    subject: user.localId,\n    issuer: `https://securetoken.google.com/${projectId}`,\n    audience: projectId\n  });\n  return jwtStr;\n}\n\nfunction getAuthTime(user) {\n  if (user.lastLoginAt != null) {\n    const millisSinceEpoch = parseInt(user.lastLoginAt, 10);\n    const authTime = new Date(millisSinceEpoch);\n\n    if (isNaN(authTime.getTime())) {\n      throw new Error(`Internal assertion error: invalid user.lastLoginAt = ${user.lastLoginAt}`);\n    }\n\n    return authTime;\n  } else if (user.lastRefreshAt != null) {\n    const authTime = new Date(user.lastRefreshAt);\n\n    if (isNaN(authTime.getTime())) {\n      throw new Error(`Internal assertion error: invalid user.lastRefreshAt = ${user.lastRefreshAt}`);\n    }\n\n    return authTime;\n  } else {\n    throw new Error(`Internal assertion error: Missing user.lastLoginAt and user.lastRefreshAt`);\n  }\n}\n\nfunction verifyPhoneNumber(state, sessionInfo, code) {\n  const verification = state.getVerificationCodeBySessionInfo(sessionInfo);\n  errors_1.assert(verification, \"INVALID_SESSION_INFO\");\n  errors_1.assert(verification.code === code, \"INVALID_CODE\");\n  state.deleteVerificationCodeBySessionInfo(sessionInfo);\n  return verification.phoneNumber;\n}\n\nconst CUSTOM_ATTRIBUTES_MAX_LENGTH = 1000;\n\nfunction validateSerializedCustomClaims(claims) {\n  errors_1.assert(claims.length <= CUSTOM_ATTRIBUTES_MAX_LENGTH, \"CLAIMS_TOO_LARGE\");\n  let parsed;\n\n  try {\n    parsed = JSON.parse(claims);\n  } catch (_a) {\n    throw new errors_1.BadRequestError(\"INVALID_CLAIMS\");\n  }\n\n  validateCustomClaims(parsed);\n}\n\nconst FORBIDDEN_CUSTOM_CLAIMS = [\"iss\", \"aud\", \"sub\", \"iat\", \"exp\", \"nbf\", \"jti\", \"nonce\", \"azp\", \"acr\", \"amr\", \"cnf\", \"auth_time\", \"firebase\", \"at_hash\", \"c_hash\"];\n\nfunction validateCustomClaims(claims) {\n  errors_1.assert(typeof claims === \"object\" && claims != null && !Array.isArray(claims), \"INVALID_CLAIMS\");\n\n  for (const reservedField of FORBIDDEN_CUSTOM_CLAIMS) {\n    errors_1.assert(!(reservedField in claims), `FORBIDDEN_CLAIM : ${reservedField}`);\n  }\n}\n\nfunction newRandomId(length, existingIds) {\n  for (let i = 0; i < 10; i++) {\n    const id = utils_1.randomId(length);\n\n    if (!(existingIds === null || existingIds === void 0 ? void 0 : existingIds.has(id))) {\n      return id;\n    }\n  }\n\n  throw new errors_1.InternalError(\"INTERNAL_ERROR : Failed to generate a random ID after 10 attempts\", \"INTERNAL\");\n}\n\nfunction getMfaEnrollmentsFromRequest(state, request, options) {\n  const enrollments = [];\n  const phoneNumbers = new Set();\n  const enrollmentIds = new Set();\n\n  for (const enrollment of request) {\n    errors_1.assert(enrollment.phoneInfo && utils_1.isValidPhoneNumber(enrollment.phoneInfo), \"INVALID_MFA_PHONE_NUMBER : Invalid format.\");\n\n    if (!phoneNumbers.has(enrollment.phoneInfo)) {\n      const mfaEnrollmentId = (options === null || options === void 0 ? void 0 : options.generateEnrollmentIds) ? newRandomId(28, enrollmentIds) : enrollment.mfaEnrollmentId;\n      errors_1.assert(mfaEnrollmentId, \"INVALID_MFA_ENROLLMENT_ID : mfaEnrollmentId must be defined.\");\n      errors_1.assert(!enrollmentIds.has(mfaEnrollmentId), \"DUPLICATE_MFA_ENROLLMENT_ID\");\n      enrollments.push(Object.assign(Object.assign({}, enrollment), {\n        mfaEnrollmentId,\n        unobfuscatedPhoneInfo: enrollment.phoneInfo\n      }));\n      phoneNumbers.add(enrollment.phoneInfo);\n      enrollmentIds.add(mfaEnrollmentId);\n    }\n  }\n\n  return state.validateMfaEnrollments(enrollments);\n}\n\nfunction getNormalizedUri(reqBody) {\n  errors_1.assert(reqBody.requestUri, \"MISSING_REQUEST_URI\");\n  const normalizedUri = utils_1.parseAbsoluteUri(reqBody.requestUri);\n  errors_1.assert(normalizedUri, \"INVALID_REQUEST_URI\");\n\n  if (reqBody.postBody) {\n    const postBodyParams = new url_1.URLSearchParams(reqBody.postBody);\n\n    for (const key of postBodyParams.keys()) {\n      normalizedUri.searchParams.set(key, postBodyParams.get(key));\n    }\n  }\n\n  const fragment = normalizedUri.hash.replace(/^#/, \"\");\n\n  if (fragment) {\n    const fragmentParams = new url_1.URLSearchParams(fragment);\n\n    for (const key of fragmentParams.keys()) {\n      normalizedUri.searchParams.set(key, fragmentParams.get(key));\n    }\n\n    normalizedUri.hash = \"\";\n  }\n\n  return normalizedUri;\n}\n\nfunction parseClaims(idTokenOrJsonClaims) {\n  if (!idTokenOrJsonClaims) {\n    return undefined;\n  }\n\n  let claims;\n\n  if (idTokenOrJsonClaims.startsWith(\"{\")) {\n    try {\n      claims = JSON.parse(idTokenOrJsonClaims);\n    } catch (_a) {\n      throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${idTokenOrJsonClaims} ((Auth Emulator failed to parse fake id_token as strict JSON.))`);\n    }\n  } else {\n    const decoded = jsonwebtoken_1.decode(idTokenOrJsonClaims, {\n      json: true\n    });\n\n    if (!decoded) {\n      return undefined;\n    }\n\n    claims = decoded;\n  }\n\n  errors_1.assert(claims.sub, 'INVALID_IDP_RESPONSE : Invalid Idp Response: id_token missing required fields. ((Missing \"sub\" field. This field is required and must be a unique identifier.))');\n  errors_1.assert(typeof claims.sub === \"string\", 'INVALID_IDP_RESPONSE : ((The \"sub\" field must be a string.))');\n  return claims;\n}\n\nfunction fakeFetchUserInfoFromIdp(providerId, claims) {\n  const rawId = claims.sub;\n  const email = claims.email ? utils_1.canonicalizeEmailAddress(claims.email) : undefined;\n  const emailVerified = !!claims.email_verified;\n  const displayName = claims.name;\n  const photoUrl = claims.picture;\n  const response = {\n    kind: \"identitytoolkit#VerifyAssertionResponse\",\n    context: \"\",\n    providerId,\n    displayName,\n    fullName: displayName,\n    screenName: claims.screen_name,\n    email,\n    emailVerified,\n    photoUrl\n  };\n  let federatedId;\n\n  switch (providerId) {\n    case \"google.com\":\n      {\n        federatedId = `https://accounts.google.com/${rawId}`;\n        let granted_scopes = \"openid https://www.googleapis.com/auth/userinfo.profile\";\n\n        if (email) {\n          granted_scopes += \" https://www.googleapis.com/auth/userinfo.email\";\n        }\n\n        response.firstName = claims.given_name;\n        response.lastName = claims.family_name;\n        response.rawUserInfo = JSON.stringify({\n          granted_scopes,\n          id: rawId,\n          name: displayName,\n          given_name: claims.given_name,\n          family_name: claims.family_name,\n          verified_email: emailVerified,\n          locale: \"en\",\n          email,\n          picture: photoUrl\n        });\n        break;\n      }\n\n    default:\n      federatedId = rawId;\n      response.rawUserInfo = JSON.stringify(claims);\n      break;\n  }\n\n  response.federatedId = federatedId;\n  return {\n    response,\n    rawId\n  };\n}\n\nfunction handleLinkIdp(state, response, userFromIdToken) {\n  if (state.oneAccountPerEmail && response.email) {\n    const userMatchingEmail = state.getUserByEmail(response.email);\n    errors_1.assert(!userMatchingEmail || userMatchingEmail.localId === userFromIdToken.localId, \"EMAIL_EXISTS\");\n  }\n\n  response.localId = userFromIdToken.localId;\n  const fields = {};\n\n  if (state.oneAccountPerEmail && response.email && !userFromIdToken.email) {\n    fields.email = response.email;\n    fields.emailVerified = response.emailVerified;\n  }\n\n  if (response.email && response.emailVerified && (fields.email || userFromIdToken.email) === response.email) {\n    fields.emailVerified = true;\n  }\n\n  return {\n    accountUpdates: {\n      fields\n    },\n    response\n  };\n}\n\nfunction handleIdpSigninEmailNotRequired(response, userMatchingProvider) {\n  if (userMatchingProvider) {\n    return {\n      response: Object.assign(Object.assign({}, response), {\n        localId: userMatchingProvider.localId\n      }),\n      accountUpdates: {}\n    };\n  } else {\n    return handleIdpSignUp(response, {\n      emailRequired: false\n    });\n  }\n}\n\nfunction handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail) {\n  var _a, _b, _c;\n\n  if (userMatchingProvider) {\n    return {\n      response: Object.assign(Object.assign({}, response), {\n        localId: userMatchingProvider.localId\n      }),\n      accountUpdates: {}\n    };\n  } else if (userMatchingEmail) {\n    if (response.emailVerified) {\n      if ((_a = userMatchingEmail.providerUserInfo) === null || _a === void 0 ? void 0 : _a.some(info => info.providerId === response.providerId && info.rawId !== rawId)) {\n        response.emailRecycled = true;\n      }\n\n      response.localId = userMatchingEmail.localId;\n      const accountUpdates = {\n        fields: {}\n      };\n\n      if (!userMatchingEmail.emailVerified) {\n        accountUpdates.fields.passwordHash = undefined;\n        accountUpdates.fields.phoneNumber = undefined;\n        accountUpdates.fields.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n        accountUpdates.deleteProviders = (_b = userMatchingEmail.providerUserInfo) === null || _b === void 0 ? void 0 : _b.map(info => info.providerId);\n      }\n\n      accountUpdates.fields.dateOfBirth = response.dateOfBirth;\n      accountUpdates.fields.displayName = response.displayName;\n      accountUpdates.fields.language = response.language;\n      accountUpdates.fields.photoUrl = response.photoUrl;\n      accountUpdates.fields.screenName = response.screenName;\n      accountUpdates.fields.emailVerified = true;\n      return {\n        response,\n        accountUpdates\n      };\n    } else {\n      response.needConfirmation = true;\n      response.localId = userMatchingEmail.localId;\n      response.verifiedProvider = (_c = userMatchingEmail.providerUserInfo) === null || _c === void 0 ? void 0 : _c.map(info => info.providerId).filter(id => id !== state_1.PROVIDER_PASSWORD && id !== state_1.PROVIDER_PHONE);\n      return {\n        response,\n        accountUpdates: {}\n      };\n    }\n  } else {\n    return handleIdpSignUp(response, {\n      emailRequired: true\n    });\n  }\n}\n\nfunction handleIdpSignUp(response, options) {\n  const accountUpdates = {\n    fields: {\n      dateOfBirth: response.dateOfBirth,\n      displayName: response.displayName,\n      language: response.language,\n      photoUrl: response.photoUrl,\n      screenName: response.screenName\n    }\n  };\n\n  if (options.emailRequired && response.email) {\n    accountUpdates.fields.email = response.email;\n    accountUpdates.fields.emailVerified = response.emailVerified;\n  }\n\n  return {\n    response: Object.assign(Object.assign({}, response), {\n      isNewUser: true\n    }),\n    accountUpdates\n  };\n}\n\nfunction mfaPending(state, user, signInProvider) {\n  if (!user.mfaInfo) {\n    throw new Error(\"Internal assertion error: mfaPending called on user without MFA.\");\n  }\n\n  const pendingCredentialPayload = {\n    _AuthEmulatorMfaPendingCredential: \"DO NOT MODIFY\",\n    localId: user.localId,\n    signInProvider,\n    projectId: state.projectId\n  };\n\n  if (state instanceof state_1.TenantProjectState) {\n    pendingCredentialPayload.tenantId = state.tenantId;\n  }\n\n  const mfaPendingCredential = Buffer.from(JSON.stringify(pendingCredentialPayload), \"utf8\").toString(\"base64\");\n  return {\n    mfaPendingCredential,\n    mfaInfo: user.mfaInfo.map(redactMfaInfo)\n  };\n}\n\nfunction redactMfaInfo(mfaInfo) {\n  return {\n    displayName: mfaInfo.displayName,\n    enrolledAt: mfaInfo.enrolledAt,\n    mfaEnrollmentId: mfaInfo.mfaEnrollmentId,\n    phoneInfo: mfaInfo.unobfuscatedPhoneInfo ? obfuscatePhoneNumber(mfaInfo.unobfuscatedPhoneInfo) : undefined\n  };\n}\n\nfunction obfuscatePhoneNumber(phoneNumber) {\n  const split = phoneNumber.split(\"\");\n  let digitsEncountered = 0;\n\n  for (let i = split.length - 1; i >= 0; i--) {\n    if (/[0-9]/.test(split[i])) {\n      digitsEncountered++;\n\n      if (digitsEncountered > 4) {\n        split[i] = \"*\";\n      }\n    }\n  }\n\n  return split.join(\"\");\n}\n\nfunction parsePendingCredential(state, pendingCredential) {\n  let pendingCredentialPayload;\n\n  try {\n    const json = Buffer.from(pendingCredential, \"base64\").toString(\"utf8\");\n    pendingCredentialPayload = JSON.parse(json);\n  } catch (_a) {\n    errors_1.assert(false, \"((Invalid phoneVerificationInfo.mfaPendingCredential.))\");\n  }\n\n  errors_1.assert(pendingCredentialPayload._AuthEmulatorMfaPendingCredential, \"((Invalid phoneVerificationInfo.mfaPendingCredential.))\");\n  errors_1.assert(pendingCredentialPayload.projectId === state.projectId, \"INVALID_PROJECT_ID : Project ID does not match MFA pending credential.\");\n\n  if (state instanceof state_1.TenantProjectState) {\n    errors_1.assert(pendingCredentialPayload.tenantId === state.tenantId, \"INVALID_PROJECT_ID : Project ID does not match MFA pending credential.\");\n  }\n\n  const {\n    localId,\n    signInProvider\n  } = pendingCredentialPayload;\n  const user = state.getUserByLocalId(localId);\n  errors_1.assert(user, \"((User in pendingCredentialPayload does not exist.))\");\n  return {\n    user,\n    signInProvider\n  };\n}\n\nfunction createTenant(state, reqBody) {\n  var _a, _b, _c, _d, _e;\n\n  if (!(state instanceof state_1.AgentProjectState)) {\n    throw new errors_1.InternalError(\"INTERNAL_ERROR: Can only create tenant in agent project\", \"INTERNAL\");\n  }\n\n  const mfaConfig = (_a = reqBody.mfaConfig) !== null && _a !== void 0 ? _a : {};\n\n  if (!(\"state\" in mfaConfig)) {\n    mfaConfig.state = \"DISABLED\";\n  }\n\n  if (!(\"enabledProviders\" in mfaConfig)) {\n    mfaConfig.enabledProviders = [];\n  }\n\n  const tenant = {\n    displayName: reqBody.displayName,\n    allowPasswordSignup: (_b = reqBody.allowPasswordSignup) !== null && _b !== void 0 ? _b : false,\n    enableEmailLinkSignin: (_c = reqBody.enableEmailLinkSignin) !== null && _c !== void 0 ? _c : false,\n    enableAnonymousUser: (_d = reqBody.enableAnonymousUser) !== null && _d !== void 0 ? _d : false,\n    disableAuth: (_e = reqBody.disableAuth) !== null && _e !== void 0 ? _e : false,\n    mfaConfig: mfaConfig,\n    tenantId: \"\"\n  };\n  return state.createTenant(tenant);\n}\n\nfunction listTenants(state, reqBody, ctx) {\n  errors_1.assert(state instanceof state_1.AgentProjectState, \"((Can only list tenants in agent project.))\");\n  const pageSize = Math.min(Math.floor(ctx.params.query.pageSize) || 20, 1000);\n  const tenants = state.listTenants(ctx.params.query.pageToken);\n  let nextPageToken = undefined;\n\n  if (pageSize > 0 && tenants.length >= pageSize) {\n    tenants.length = pageSize;\n    nextPageToken = tenants[tenants.length - 1].tenantId;\n  }\n\n  return {\n    nextPageToken,\n    tenants\n  };\n}\n\nfunction deleteTenant(state, reqBody, ctx) {\n  errors_1.assert(state instanceof state_1.TenantProjectState, \"((Can only delete tenant on tenant projects.))\");\n  state.delete();\n  return {};\n}\n\nfunction getTenant(state, reqBody, ctx) {\n  errors_1.assert(state instanceof state_1.TenantProjectState, \"((Can only get tenant on tenant projects.))\");\n  return state.tenantConfig;\n}\n\nfunction updateTenant(state, reqBody, ctx) {\n  errors_1.assert(state instanceof state_1.TenantProjectState, \"((Can only update tenant on tenant projects.))\");\n  return state.updateTenant(reqBody, ctx.params.query.updateMask);\n}","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/emulator/auth/operations.js"],"names":["Object","defineProperty","exports","value","setAccountInfoImpl","resetPassword","SESSION_COOKIE_MAX_VALID_DURATION","CUSTOM_TOKEN_AUDIENCE","authOperations","url_1","require","jsonwebtoken_1","utils_1","errors_1","types_1","emulatorLogger_1","state_1","identitytoolkit","getProjects","getRecaptchaParams","accounts","createAuthUri","delete","deleteAccount","lookup","sendOobCode","sendVerificationCode","signInWithCustomToken","signInWithEmailLink","signInWithIdp","signInWithPassword","signInWithPhoneNumber","signUp","update","setAccountInfo","mfaEnrollment","finalize","mfaEnrollmentFinalize","start","mfaEnrollmentStart","withdraw","mfaEnrollmentWithdraw","mfaSignIn","mfaSignInStart","mfaSignInFinalize","projects","createSessionCookie","queryAccounts","_","query","batchCreate","batchDelete","batchGet","tenants","create","createTenant","deleteTenant","get","getTenant","list","listTenants","patch","updateTenant","securetoken","token","grantToken","emulator","deleteAllAccountsInProject","config","getEmulatorProjectConfig","updateEmulatorProjectConfig","oobCodes","listOobCodesInProject","verificationCodes","listVerificationCodesInProject","PASSWORD_MIN_LENGTH","MFA_INELIGIBLE_PROVIDER","Set","PROVIDER_ANONYMOUS","PROVIDER_PHONE","PROVIDER_CUSTOM","PROVIDER_GAME_CENTER","state","reqBody","ctx","_a","assert","disableAuth","usageMode","UsageMode","PASSTHROUGH","provider","updates","lastLoginAt","Date","now","toString","security","Oauth2","idToken","localId","getUserByLocalId","displayName","photoUrl","emailVerified","phoneNumber","isValidPhoneNumber","getUserByPhoneNumber","disabled","password","email","PROVIDER_PASSWORD","allowPasswordSignup","enableAnonymousUser","isValidEmailAddress","canonicalizeEmailAddress","getUserByEmail","length","salt","randomId","passwordHash","hashPassword","passwordUpdatedAt","validSince","toUnixTimestamp","mfaInfo","getMfaEnrollmentsFromRequest","generateEnrollmentIds","TenantProjectState","tenantId","user","parseIdToken","createUserWithLocalId","createUser","updateUserByLocalId","assign","kind","issueTokens","_b","_c","_d","_e","seenLocalIds","users","tryAddUser","maybeUser","has","push","add","initialEmail","NotImplementedError","providerId","rawId","federatedUserId","getUserByProviderRawId","redactPasswordHash","undefined","sanityCheck","oneAccountPerEmail","existingEmails","userInfo","existingProviderAccounts","providerUserInfo","key","allowOverwrite","existingLocalIds","errors","index","uploadTime","fields","getTime","rawPassword","customAttributes","validateSerializedCustomClaims","federatedId","existingUserWithRawId","createdAt","isNaN","Number","existingUserWithEmail","existingIds","enrollment","mfaEnrollmentId","newRandomId","enrolledAt","toISOString","phoneInfo","unobfuscatedPhoneInfo","overwriteUserWithLocalId","e","BadRequestError","message","startsWith","error","localIds","force","deleteUser","maxResults","Math","min","floor","params","queryUsers","sortByField","order","startToken","nextPageToken","newPageToken","sessionId","identifier","continueUri","parseAbsoluteUri","allProviders","signinMethods","registered","getUsersByEmailOrProviderEmail","forEach","emailLinkSignin","SIGNIN_METHOD_EMAIL_LINK","find","u","SESSION_COOKIE_MIN_VALID_DURATION","validDuration","payload","issuedAt","expiresAt","sessionCookie","sign","iat","exp","iss","aud","algorithm","AgentProjectState","projectId","projectNumber","authorizedDomains","recaptchaStoken","recaptchaSiteKey","expression","returnUserInfo","recordsCount","getUserCount","limit","offset","sortBy","oobCode","oob","validateOobCode","newPassword","requestType","deleteOobCode","deleteProviders","map","info","returnOobLink","continueUrl","mode","enableEmailLinkSignin","canHandleCodeInApp","EmulatorLogger","forEmulator","Emulators","AUTH","log","url","authEmulatorUrl","req","oobRecord","createOobRecord","oobLink","logOobMessage","sessionInfo","code","createVerificationCode","privileged","emulatorUrl","unimplementedFields","field","deleteAttribute","attr","signInProvider","isEmailUpdate","getUserByInitialEmail","disableUser","newEmail","mfa","enrollments","fieldsToCopy","mirrorFieldTo","deleteProvider","includes","Error","sendOobForEmailReset","createOob","pathname","searchParams","set","maybeMessage","JSON","parse","decoded","decode","complete","tenant_id","header","alg","coercePrimitiveToString","uid","user_id","extraClaims","validateCustomClaims","claims","isNewUser","customAuth","userFromIdToken","response","mfaConfig","mfaPending","returnRefreshToken","pendingIdToken","normalizedUri","getNormalizedUri","toLowerCase","oauthIdToken","oauthAccessToken","parseClaims","fakeFetchUserInfoFromIdp","userMatchingProvider","accountUpdates","handleLinkIdp","userMatchingEmail","handleIdpSigninEmailRequired","handleIdpSigninEmailNotRequired","err","returnIdpCredential","errorMessage","needConfirmation","screenName","upsertProviders","captchaResponse","captchaChallenge","temporaryProof","proof","validateTemporaryProof","verifyPhoneNumber","createTemporaryProof","tokens","grantType","refreshToken","refreshTokenRecord","validateRefreshToken","secondFactor","id_token","access_token","expires_in","expiresIn","refresh_token","token_type","project_id","deleteAllAccounts","signIn","allowDuplicateEmails","DEFAULT","listOobCodes","listVerificationCodes","enabledProviders","phoneEnrollmentInfo","some","phoneSessionInfo","phoneVerificationInfo","androidVerificationProof","existingFactors","updatedList","filter","mfaPendingCredential","parsePendingCredential","factor","phoneResponseInfo","lastRefreshAt","expiresInSeconds","generateJwt","createRefreshTokenFor","firebase","tenant","sign_in_provider","identities","providerInfo","ids","customPayloadFields","name","picture","email_verified","phone_number","provider_id","auth_time","getAuthTime","second_factor_identifier","sign_in_second_factor","usage_mode","jwtStr","subject","issuer","audience","millisSinceEpoch","parseInt","authTime","verification","getVerificationCodeBySessionInfo","deleteVerificationCodeBySessionInfo","CUSTOM_ATTRIBUTES_MAX_LENGTH","parsed","FORBIDDEN_CUSTOM_CLAIMS","Array","isArray","reservedField","i","id","InternalError","request","options","phoneNumbers","enrollmentIds","validateMfaEnrollments","requestUri","postBody","postBodyParams","URLSearchParams","keys","fragment","hash","replace","fragmentParams","idTokenOrJsonClaims","json","sub","context","fullName","screen_name","granted_scopes","firstName","given_name","lastName","family_name","rawUserInfo","stringify","verified_email","locale","handleIdpSignUp","emailRequired","emailRecycled","dateOfBirth","language","verifiedProvider","pendingCredentialPayload","_AuthEmulatorMfaPendingCredential","Buffer","from","redactMfaInfo","obfuscatePhoneNumber","split","digitsEncountered","test","join","pendingCredential","pageSize","pageToken","tenantConfig","updateMask"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setAccountInfoImpl = exports.resetPassword = exports.SESSION_COOKIE_MAX_VALID_DURATION = exports.CUSTOM_TOKEN_AUDIENCE = exports.authOperations = void 0;\nconst url_1 = require(\"url\");\nconst jsonwebtoken_1 = require(\"jsonwebtoken\");\nconst utils_1 = require(\"./utils\");\nconst errors_1 = require(\"./errors\");\nconst types_1 = require(\"../types\");\nconst emulatorLogger_1 = require(\"../emulatorLogger\");\nconst state_1 = require(\"./state\");\nexports.authOperations = {\n    identitytoolkit: {\n        getProjects,\n        getRecaptchaParams,\n        accounts: {\n            createAuthUri,\n            delete: deleteAccount,\n            lookup,\n            resetPassword,\n            sendOobCode,\n            sendVerificationCode,\n            signInWithCustomToken,\n            signInWithEmailLink,\n            signInWithIdp,\n            signInWithPassword,\n            signInWithPhoneNumber,\n            signUp,\n            update: setAccountInfo,\n            mfaEnrollment: {\n                finalize: mfaEnrollmentFinalize,\n                start: mfaEnrollmentStart,\n                withdraw: mfaEnrollmentWithdraw,\n            },\n            mfaSignIn: {\n                start: mfaSignInStart,\n                finalize: mfaSignInFinalize,\n            },\n        },\n        projects: {\n            createSessionCookie,\n            queryAccounts,\n            accounts: {\n                _: signUp,\n                delete: deleteAccount,\n                lookup,\n                query: queryAccounts,\n                sendOobCode,\n                update: setAccountInfo,\n                batchCreate,\n                batchDelete,\n                batchGet,\n            },\n            tenants: {\n                create: createTenant,\n                delete: deleteTenant,\n                get: getTenant,\n                list: listTenants,\n                patch: updateTenant,\n                createSessionCookie,\n                accounts: {\n                    _: signUp,\n                    batchCreate,\n                    batchDelete,\n                    batchGet,\n                    delete: deleteAccount,\n                    lookup,\n                    query: queryAccounts,\n                    sendOobCode,\n                    update: setAccountInfo,\n                },\n            },\n        },\n    },\n    securetoken: {\n        token: grantToken,\n    },\n    emulator: {\n        projects: {\n            accounts: {\n                delete: deleteAllAccountsInProject,\n            },\n            config: {\n                get: getEmulatorProjectConfig,\n                update: updateEmulatorProjectConfig,\n            },\n            oobCodes: {\n                list: listOobCodesInProject,\n            },\n            verificationCodes: {\n                list: listVerificationCodesInProject,\n            },\n        },\n    },\n};\nconst PASSWORD_MIN_LENGTH = 6;\nexports.CUSTOM_TOKEN_AUDIENCE = \"https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit\";\nconst MFA_INELIGIBLE_PROVIDER = new Set([\n    state_1.PROVIDER_ANONYMOUS,\n    state_1.PROVIDER_PHONE,\n    state_1.PROVIDER_CUSTOM,\n    state_1.PROVIDER_GAME_CENTER,\n]);\nfunction signUp(state, reqBody, ctx) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    let provider;\n    const updates = {\n        lastLoginAt: Date.now().toString(),\n    };\n    if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n        if (reqBody.idToken) {\n            errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n        }\n        if (reqBody.localId) {\n            errors_1.assert(!state.getUserByLocalId(reqBody.localId), \"DUPLICATE_LOCAL_ID\");\n        }\n        updates.displayName = reqBody.displayName;\n        updates.photoUrl = reqBody.photoUrl;\n        updates.emailVerified = reqBody.emailVerified || false;\n        if (reqBody.phoneNumber) {\n            errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n            errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n            updates.phoneNumber = reqBody.phoneNumber;\n        }\n        if (reqBody.disabled) {\n            updates.disabled = true;\n        }\n    }\n    else {\n        errors_1.assert(!reqBody.localId, \"UNEXPECTED_PARAMETER : User ID\");\n        if (reqBody.idToken || reqBody.password || reqBody.email) {\n            updates.displayName = reqBody.displayName;\n            updates.emailVerified = false;\n            errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n            errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n            provider = state_1.PROVIDER_PASSWORD;\n            errors_1.assert(state.allowPasswordSignup, \"OPERATION_NOT_ALLOWED\");\n        }\n        else {\n            provider = state_1.PROVIDER_ANONYMOUS;\n            errors_1.assert(state.enableAnonymousUser, \"ADMIN_ONLY_OPERATION\");\n        }\n    }\n    if (reqBody.email) {\n        errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n        const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n        errors_1.assert(!state.getUserByEmail(email), \"EMAIL_EXISTS\");\n        updates.email = email;\n    }\n    if (reqBody.password) {\n        errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n        updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n        updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n        updates.passwordUpdatedAt = Date.now();\n        updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n    }\n    if (reqBody.mfaInfo) {\n        updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfaInfo, {\n            generateEnrollmentIds: true,\n        });\n    }\n    if (state instanceof state_1.TenantProjectState) {\n        updates.tenantId = state.tenantId;\n    }\n    let user;\n    if (reqBody.idToken) {\n        ({ user } = parseIdToken(state, reqBody.idToken));\n    }\n    if (!user) {\n        if (reqBody.localId) {\n            user = state.createUserWithLocalId(reqBody.localId, updates);\n            errors_1.assert(user, \"DUPLICATE_LOCAL_ID\");\n        }\n        else {\n            user = state.createUser(updates);\n        }\n    }\n    else {\n        user = state.updateUserByLocalId(user.localId, updates);\n    }\n    return Object.assign({ kind: \"identitytoolkit#SignupNewUserResponse\", localId: user.localId, displayName: user.displayName, email: user.email }, (provider ? issueTokens(state, user, provider) : {}));\n}\nfunction lookup(state, reqBody, ctx) {\n    var _a, _b, _c, _d, _e;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    const seenLocalIds = new Set();\n    const users = [];\n    function tryAddUser(maybeUser) {\n        if (maybeUser && !seenLocalIds.has(maybeUser.localId)) {\n            users.push(maybeUser);\n            seenLocalIds.add(maybeUser.localId);\n        }\n    }\n    if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n        if (reqBody.initialEmail) {\n            throw new errors_1.NotImplementedError(\"Lookup by initialEmail is not implemented.\");\n        }\n        for (const localId of (_b = reqBody.localId) !== null && _b !== void 0 ? _b : []) {\n            tryAddUser(state.getUserByLocalId(localId));\n        }\n        for (const email of (_c = reqBody.email) !== null && _c !== void 0 ? _c : []) {\n            tryAddUser(state.getUserByEmail(email));\n        }\n        for (const phoneNumber of (_d = reqBody.phoneNumber) !== null && _d !== void 0 ? _d : []) {\n            tryAddUser(state.getUserByPhoneNumber(phoneNumber));\n        }\n        for (const { providerId, rawId } of (_e = reqBody.federatedUserId) !== null && _e !== void 0 ? _e : []) {\n            if (!providerId || !rawId) {\n                continue;\n            }\n            tryAddUser(state.getUserByProviderRawId(providerId, rawId));\n        }\n    }\n    else {\n        errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n        const { user } = parseIdToken(state, reqBody.idToken);\n        users.push(redactPasswordHash(user));\n    }\n    return {\n        kind: \"identitytoolkit#GetAccountInfoResponse\",\n        users: users.length ? users : undefined,\n    };\n}\nfunction batchCreate(state, reqBody) {\n    var _a, _b;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert((_a = reqBody.users) === null || _a === void 0 ? void 0 : _a.length, \"MISSING_USER_ACCOUNT\");\n    if (reqBody.sanityCheck) {\n        if (state.oneAccountPerEmail) {\n            const existingEmails = new Set();\n            for (const userInfo of reqBody.users) {\n                if (userInfo.email) {\n                    errors_1.assert(!existingEmails.has(userInfo.email), `DUPLICATE_EMAIL : ${userInfo.email}`);\n                    existingEmails.add(userInfo.email);\n                }\n            }\n        }\n        const existingProviderAccounts = new Set();\n        for (const userInfo of reqBody.users) {\n            for (const { providerId, rawId } of (_b = userInfo.providerUserInfo) !== null && _b !== void 0 ? _b : []) {\n                const key = `${providerId}:${rawId}`;\n                errors_1.assert(!existingProviderAccounts.has(key), `DUPLICATE_RAW_ID : Provider id(${providerId}), Raw id(${rawId})`);\n                existingProviderAccounts.add(key);\n            }\n        }\n    }\n    if (!reqBody.allowOverwrite) {\n        const existingLocalIds = new Set();\n        for (const userInfo of reqBody.users) {\n            const localId = userInfo.localId || \"\";\n            errors_1.assert(!existingLocalIds.has(localId), `DUPLICATE_LOCAL_ID : ${localId}`);\n            existingLocalIds.add(localId);\n        }\n    }\n    const errors = [];\n    for (let index = 0; index < reqBody.users.length; index++) {\n        const userInfo = reqBody.users[index];\n        try {\n            errors_1.assert(userInfo.localId, \"localId is missing\");\n            const uploadTime = new Date();\n            const fields = {\n                displayName: userInfo.displayName,\n                photoUrl: userInfo.photoUrl,\n                lastLoginAt: userInfo.lastLoginAt,\n            };\n            if (userInfo.tenantId) {\n                errors_1.assert(state instanceof state_1.TenantProjectState && state.tenantId === userInfo.tenantId, \"Tenant id in userInfo does not match the tenant id in request.\");\n            }\n            if (state instanceof state_1.TenantProjectState) {\n                fields.tenantId = state.tenantId;\n            }\n            if (userInfo.passwordHash) {\n                fields.passwordHash = userInfo.passwordHash;\n                fields.salt = userInfo.salt;\n                fields.passwordUpdatedAt = uploadTime.getTime();\n            }\n            else if (userInfo.rawPassword) {\n                fields.salt = userInfo.salt || \"fakeSalt\" + utils_1.randomId(20);\n                fields.passwordHash = hashPassword(userInfo.rawPassword, fields.salt);\n                fields.passwordUpdatedAt = uploadTime.getTime();\n            }\n            if (userInfo.customAttributes) {\n                validateSerializedCustomClaims(userInfo.customAttributes);\n                fields.customAttributes = userInfo.customAttributes;\n            }\n            if (userInfo.providerUserInfo) {\n                fields.providerUserInfo = [];\n                for (const providerUserInfo of userInfo.providerUserInfo) {\n                    const { providerId, rawId, federatedId } = providerUserInfo;\n                    if (providerId === state_1.PROVIDER_PASSWORD || providerId === state_1.PROVIDER_PHONE) {\n                        continue;\n                    }\n                    if (!rawId || !providerId) {\n                        if (!federatedId) {\n                            errors_1.assert(false, \"federatedId or (providerId & rawId) is required\");\n                        }\n                        else {\n                            errors_1.assert(false, \"((Parsing federatedId is not implemented in Auth Emulator; please specify providerId AND rawId as a workaround.))\");\n                        }\n                    }\n                    const existingUserWithRawId = state.getUserByProviderRawId(providerId, rawId);\n                    errors_1.assert(!existingUserWithRawId || existingUserWithRawId.localId === userInfo.localId, \"raw id exists in other account in database\");\n                    fields.providerUserInfo.push(Object.assign(Object.assign({}, providerUserInfo), { providerId, rawId }));\n                }\n            }\n            if (userInfo.phoneNumber) {\n                errors_1.assert(utils_1.isValidPhoneNumber(userInfo.phoneNumber), \"phone number format is invalid\");\n                fields.phoneNumber = userInfo.phoneNumber;\n            }\n            fields.validSince = utils_1.toUnixTimestamp(uploadTime).toString();\n            fields.createdAt = uploadTime.getTime().toString();\n            if (fields.createdAt && !isNaN(Number(userInfo.createdAt))) {\n                fields.createdAt = userInfo.createdAt;\n            }\n            if (userInfo.email) {\n                const email = userInfo.email;\n                errors_1.assert(utils_1.isValidEmailAddress(email), \"email is invalid\");\n                const existingUserWithEmail = state.getUserByEmail(email);\n                errors_1.assert(!existingUserWithEmail || existingUserWithEmail.localId === userInfo.localId, reqBody.sanityCheck && state.oneAccountPerEmail\n                    ? \"email exists in other account in database\"\n                    : `((Auth Emulator does not support importing duplicate email: ${email}))`);\n                fields.email = utils_1.canonicalizeEmailAddress(email);\n            }\n            fields.emailVerified = !!userInfo.emailVerified;\n            fields.disabled = !!userInfo.disabled;\n            if (userInfo.mfaInfo) {\n                fields.mfaInfo = [];\n                errors_1.assert(fields.email, \"Second factor account requires email to be presented.\");\n                errors_1.assert(fields.emailVerified, \"Second factor account requires email to be verified.\");\n                const existingIds = new Set();\n                for (const enrollment of userInfo.mfaInfo) {\n                    if (enrollment.mfaEnrollmentId) {\n                        errors_1.assert(!existingIds.has(enrollment.mfaEnrollmentId), \"Enrollment id already exists.\");\n                        existingIds.add(enrollment.mfaEnrollmentId);\n                    }\n                }\n                for (const enrollment of userInfo.mfaInfo) {\n                    enrollment.mfaEnrollmentId = enrollment.mfaEnrollmentId || newRandomId(28, existingIds);\n                    enrollment.enrolledAt = enrollment.enrolledAt || new Date().toISOString();\n                    errors_1.assert(enrollment.phoneInfo, \"Second factor not supported.\");\n                    errors_1.assert(utils_1.isValidPhoneNumber(enrollment.phoneInfo), \"Phone number format is invalid\");\n                    enrollment.unobfuscatedPhoneInfo = enrollment.phoneInfo;\n                    fields.mfaInfo.push(enrollment);\n                }\n            }\n            if (state.getUserByLocalId(userInfo.localId)) {\n                errors_1.assert(reqBody.allowOverwrite, \"localId belongs to an existing account - can not overwrite.\");\n            }\n            state.overwriteUserWithLocalId(userInfo.localId, fields);\n        }\n        catch (e) {\n            if (e instanceof errors_1.BadRequestError) {\n                let message = e.message;\n                if (message === \"INVALID_CLAIMS\") {\n                    message = \"Invalid custom claims provided.\";\n                }\n                else if (message === \"CLAIMS_TOO_LARGE\") {\n                    message = \"Custom claims provided are too large.\";\n                }\n                else if (message.startsWith(\"FORBIDDEN_CLAIM\")) {\n                    message = \"Custom claims provided include a reserved claim.\";\n                }\n                errors.push({\n                    index,\n                    message,\n                });\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    return {\n        kind: \"identitytoolkit#UploadAccountResponse\",\n        error: errors,\n    };\n}\nfunction batchDelete(state, reqBody) {\n    var _a;\n    const errors = [];\n    const localIds = (_a = reqBody.localIds) !== null && _a !== void 0 ? _a : [];\n    errors_1.assert(localIds.length > 0 && localIds.length <= 1000, \"LOCAL_ID_LIST_EXCEEDS_LIMIT\");\n    for (let index = 0; index < localIds.length; index++) {\n        const localId = localIds[index];\n        const user = state.getUserByLocalId(localId);\n        if (!user) {\n            continue;\n        }\n        else if (!user.disabled && !reqBody.force) {\n            errors.push({\n                index,\n                localId,\n                message: \"NOT_DISABLED : Disable the account before batch deletion.\",\n            });\n        }\n        else {\n            state.deleteUser(user);\n        }\n    }\n    return { errors: errors.length ? errors : undefined };\n}\nfunction batchGet(state, reqBody, ctx) {\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    const maxResults = Math.min(Math.floor(ctx.params.query.maxResults) || 20, 1000);\n    const users = state.queryUsers({}, { sortByField: \"localId\", order: \"ASC\", startToken: ctx.params.query.nextPageToken });\n    let newPageToken = undefined;\n    if (maxResults >= 0 && users.length >= maxResults) {\n        users.length = maxResults;\n        if (users.length) {\n            newPageToken = users[users.length - 1].localId;\n        }\n    }\n    return {\n        kind: \"identitytoolkit#DownloadAccountResponse\",\n        users,\n        nextPageToken: newPageToken,\n    };\n}\nfunction createAuthUri(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    const sessionId = reqBody.sessionId || utils_1.randomId(27);\n    if (reqBody.providerId) {\n        throw new errors_1.NotImplementedError(\"Sign-in with IDP is not yet supported.\");\n    }\n    errors_1.assert(reqBody.identifier, \"MISSING_IDENTIFIER\");\n    errors_1.assert(reqBody.continueUri, \"MISSING_CONTINUE_URI\");\n    errors_1.assert(utils_1.isValidEmailAddress(reqBody.identifier), \"INVALID_IDENTIFIER\");\n    const email = utils_1.canonicalizeEmailAddress(reqBody.identifier);\n    errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUri), \"INVALID_CONTINUE_URI\");\n    const allProviders = [];\n    const signinMethods = [];\n    let registered = false;\n    const users = state.getUsersByEmailOrProviderEmail(email);\n    if (state.oneAccountPerEmail) {\n        if (users.length) {\n            registered = true;\n            (_a = users[0].providerUserInfo) === null || _a === void 0 ? void 0 : _a.forEach(({ providerId }) => {\n                if (providerId === state_1.PROVIDER_PASSWORD) {\n                    allProviders.push(providerId);\n                    if (users[0].passwordHash) {\n                        signinMethods.push(state_1.PROVIDER_PASSWORD);\n                    }\n                    if (users[0].emailLinkSignin) {\n                        signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n                    }\n                }\n                else if (providerId !== state_1.PROVIDER_PHONE) {\n                    allProviders.push(providerId);\n                    signinMethods.push(providerId);\n                }\n            });\n        }\n    }\n    else {\n        const user = users.find((u) => u.email);\n        if (user) {\n            registered = true;\n            if (user.passwordHash || user.emailLinkSignin) {\n                allProviders.push(state_1.PROVIDER_PASSWORD);\n                if (users[0].passwordHash) {\n                    signinMethods.push(state_1.PROVIDER_PASSWORD);\n                }\n                if (users[0].emailLinkSignin) {\n                    signinMethods.push(state_1.SIGNIN_METHOD_EMAIL_LINK);\n                }\n            }\n        }\n    }\n    return {\n        kind: \"identitytoolkit#CreateAuthUriResponse\",\n        registered,\n        allProviders,\n        sessionId,\n        signinMethods,\n    };\n}\nconst SESSION_COOKIE_MIN_VALID_DURATION = 5 * 60;\nexports.SESSION_COOKIE_MAX_VALID_DURATION = 14 * 24 * 60 * 60;\nfunction createSessionCookie(state, reqBody, ctx) {\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    const validDuration = Number(reqBody.validDuration) || exports.SESSION_COOKIE_MAX_VALID_DURATION;\n    errors_1.assert(validDuration >= SESSION_COOKIE_MIN_VALID_DURATION &&\n        validDuration <= exports.SESSION_COOKIE_MAX_VALID_DURATION, \"INVALID_DURATION\");\n    const { payload } = parseIdToken(state, reqBody.idToken);\n    const issuedAt = utils_1.toUnixTimestamp(new Date());\n    const expiresAt = issuedAt + validDuration;\n    const sessionCookie = jsonwebtoken_1.sign(Object.assign(Object.assign({}, payload), { iat: issuedAt, exp: expiresAt, iss: `https://session.firebase.google.com/${payload.aud}` }), \"\", {\n        algorithm: \"none\",\n    });\n    return { sessionCookie };\n}\nfunction deleteAccount(state, reqBody, ctx) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    let user;\n    if ((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2) {\n        errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n        const maybeUser = state.getUserByLocalId(reqBody.localId);\n        errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n        user = maybeUser;\n    }\n    else {\n        errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n        user = parseIdToken(state, reqBody.idToken).user;\n    }\n    state.deleteUser(user);\n    return {\n        kind: \"identitytoolkit#DeleteAccountResponse\",\n    };\n}\nfunction getProjects(state) {\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state instanceof state_1.AgentProjectState, \"UNSUPPORTED_TENANT_OPERATION\");\n    return {\n        projectId: state.projectNumber,\n        authorizedDomains: [\n            \"localhost\",\n        ],\n    };\n}\nfunction getRecaptchaParams(state) {\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    return {\n        kind: \"identitytoolkit#GetRecaptchaParamResponse\",\n        recaptchaStoken: \"This-is-a-fake-token__Dont-send-this-to-the-Recaptcha-service__The-Auth-Emulator-does-not-support-Recaptcha\",\n        recaptchaSiteKey: \"Fake-key__Do-not-send-this-to-Recaptcha_\",\n    };\n}\nfunction queryAccounts(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    if ((_a = reqBody.expression) === null || _a === void 0 ? void 0 : _a.length) {\n        throw new errors_1.NotImplementedError(\"expression is not implemented.\");\n    }\n    if (reqBody.returnUserInfo === false) {\n        return {\n            recordsCount: state.getUserCount().toString(),\n        };\n    }\n    if (reqBody.limit) {\n        throw new errors_1.NotImplementedError(\"limit is not implemented.\");\n    }\n    reqBody.offset = reqBody.offset || \"0\";\n    if (reqBody.offset !== \"0\") {\n        throw new errors_1.NotImplementedError(\"offset is not implemented.\");\n    }\n    if (!reqBody.order || reqBody.order === \"ORDER_UNSPECIFIED\") {\n        reqBody.order = \"ASC\";\n    }\n    if (!reqBody.sortBy || reqBody.sortBy === \"SORT_BY_FIELD_UNSPECIFIED\") {\n        reqBody.sortBy = \"USER_ID\";\n    }\n    let sortByField;\n    if (reqBody.sortBy === \"USER_ID\") {\n        sortByField = \"localId\";\n    }\n    else {\n        throw new errors_1.NotImplementedError(\"Only sorting by USER_ID is implemented.\");\n    }\n    const users = state.queryUsers({}, { order: reqBody.order, sortByField });\n    return {\n        recordsCount: users.length.toString(),\n        userInfo: users,\n    };\n}\nfunction resetPassword(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert(state.allowPasswordSignup, \"PASSWORD_LOGIN_DISABLED\");\n    errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n    const oob = state.validateOobCode(reqBody.oobCode);\n    errors_1.assert(oob, \"INVALID_OOB_CODE\");\n    if (reqBody.newPassword) {\n        errors_1.assert(oob.requestType === \"PASSWORD_RESET\", \"INVALID_OOB_CODE\");\n        errors_1.assert(reqBody.newPassword.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n        state.deleteOobCode(reqBody.oobCode);\n        let user = state.getUserByEmail(oob.email);\n        errors_1.assert(user, \"INVALID_OOB_CODE\");\n        const salt = \"fakeSalt\" + utils_1.randomId(20);\n        const passwordHash = hashPassword(reqBody.newPassword, salt);\n        user = state.updateUserByLocalId(user.localId, {\n            emailVerified: true,\n            passwordHash,\n            salt,\n            passwordUpdatedAt: Date.now(),\n            validSince: utils_1.toUnixTimestamp(new Date()).toString(),\n        }, { deleteProviders: (_a = user.providerUserInfo) === null || _a === void 0 ? void 0 : _a.map((info) => info.providerId) });\n    }\n    return {\n        kind: \"identitytoolkit#ResetPasswordResponse\",\n        requestType: oob.requestType,\n        email: oob.requestType === \"EMAIL_SIGNIN\" ? undefined : oob.email,\n    };\n}\nexports.resetPassword = resetPassword;\nfunction sendOobCode(state, reqBody, ctx) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert(reqBody.requestType && reqBody.requestType !== \"OOB_REQ_TYPE_UNSPECIFIED\", \"MISSING_REQ_TYPE\");\n    if (reqBody.returnOobLink) {\n        errors_1.assert((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2, \"INSUFFICIENT_PERMISSION\");\n    }\n    if (reqBody.continueUrl) {\n        errors_1.assert(utils_1.parseAbsoluteUri(reqBody.continueUrl), \"INVALID_CONTINUE_URI: ((expected an absolute URI with valid scheme and host))\");\n    }\n    let email;\n    let mode;\n    switch (reqBody.requestType) {\n        case \"EMAIL_SIGNIN\":\n            errors_1.assert(state.enableEmailLinkSignin, \"OPERATION_NOT_ALLOWED\");\n            mode = \"signIn\";\n            errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n            email = utils_1.canonicalizeEmailAddress(reqBody.email);\n            break;\n        case \"PASSWORD_RESET\":\n            mode = \"resetPassword\";\n            errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n            email = utils_1.canonicalizeEmailAddress(reqBody.email);\n            errors_1.assert(state.getUserByEmail(email), \"EMAIL_NOT_FOUND\");\n            break;\n        case \"VERIFY_EMAIL\":\n            mode = \"verifyEmail\";\n            if (reqBody.returnOobLink && !reqBody.idToken) {\n                errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n                email = utils_1.canonicalizeEmailAddress(reqBody.email);\n                const maybeUser = state.getUserByEmail(email);\n                errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n            }\n            else {\n                const user = parseIdToken(state, reqBody.idToken || \"\").user;\n                errors_1.assert(user.email, \"MISSING_EMAIL\");\n                email = user.email;\n            }\n            break;\n        default:\n            throw new errors_1.NotImplementedError(reqBody.requestType);\n    }\n    if (reqBody.canHandleCodeInApp) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"canHandleCodeInApp is unsupported in Auth Emulator. All OOB operations will complete via web.\");\n    }\n    const url = utils_1.authEmulatorUrl(ctx.req);\n    const oobRecord = createOobRecord(state, email, url, {\n        requestType: reqBody.requestType,\n        mode,\n        continueUrl: reqBody.continueUrl,\n    });\n    if (reqBody.returnOobLink) {\n        return {\n            kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n            email,\n            oobCode: oobRecord.oobCode,\n            oobLink: oobRecord.oobLink,\n        };\n    }\n    else {\n        logOobMessage(oobRecord);\n        return {\n            kind: \"identitytoolkit#GetOobConfirmationCodeResponse\",\n            email,\n        };\n    }\n}\nfunction sendVerificationCode(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state instanceof state_1.AgentProjectState, \"UNSUPPORTED_TENANT_OPERATION\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert(reqBody.phoneNumber && utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n    const user = state.getUserByPhoneNumber(reqBody.phoneNumber);\n    errors_1.assert(!((_a = user === null || user === void 0 ? void 0 : user.mfaInfo) === null || _a === void 0 ? void 0 : _a.length), \"UNSUPPORTED_FIRST_FACTOR : A phone number cannot be set as a first factor on an SMS based MFA user.\");\n    const { sessionInfo, phoneNumber, code } = state.createVerificationCode(reqBody.phoneNumber);\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To verify the phone number ${phoneNumber}, use the code ${code}.`);\n    return {\n        sessionInfo,\n    };\n}\nfunction setAccountInfo(state, reqBody, ctx) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    const url = utils_1.authEmulatorUrl(ctx.req);\n    return setAccountInfoImpl(state, reqBody, {\n        privileged: !!((_a = ctx.security) === null || _a === void 0 ? void 0 : _a.Oauth2),\n        emulatorUrl: url,\n    });\n}\nfunction setAccountInfoImpl(state, reqBody, { privileged = false, emulatorUrl = undefined } = {}) {\n    var _a, _b;\n    const unimplementedFields = [\n        \"provider\",\n        \"upgradeToFederatedLogin\",\n        \"linkProviderUserInfo\",\n    ];\n    for (const field of unimplementedFields) {\n        if (field in reqBody) {\n            throw new errors_1.NotImplementedError(`${field} is not implemented yet.`);\n        }\n    }\n    if (!privileged) {\n        errors_1.assert(reqBody.idToken || reqBody.oobCode, \"INVALID_REQ_TYPE : Unsupported request parameters.\");\n        errors_1.assert(reqBody.customAttributes == null, \"INSUFFICIENT_PERMISSION\");\n    }\n    else {\n        errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n    }\n    if (reqBody.customAttributes) {\n        validateSerializedCustomClaims(reqBody.customAttributes);\n    }\n    reqBody.deleteAttribute = reqBody.deleteAttribute || [];\n    for (const attr of reqBody.deleteAttribute) {\n        if (attr === \"PROVIDER\" || attr === \"RAW_USER_INFO\") {\n            throw new errors_1.NotImplementedError(`deleteAttribute: ${attr}`);\n        }\n    }\n    const updates = {};\n    let user;\n    let signInProvider;\n    let isEmailUpdate = false;\n    if (reqBody.oobCode) {\n        const oob = state.validateOobCode(reqBody.oobCode);\n        errors_1.assert(oob, \"INVALID_OOB_CODE\");\n        switch (oob.requestType) {\n            case \"VERIFY_EMAIL\": {\n                state.deleteOobCode(reqBody.oobCode);\n                signInProvider = state_1.PROVIDER_PASSWORD;\n                const maybeUser = state.getUserByEmail(oob.email);\n                errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n                user = maybeUser;\n                updates.emailVerified = true;\n                if (oob.email !== user.email) {\n                    updates.email = oob.email;\n                }\n                break;\n            }\n            case \"RECOVER_EMAIL\": {\n                state.deleteOobCode(reqBody.oobCode);\n                const maybeUser = state.getUserByInitialEmail(oob.email);\n                errors_1.assert(maybeUser, \"INVALID_OOB_CODE\");\n                errors_1.assert(!state.getUserByEmail(oob.email), \"EMAIL_EXISTS\");\n                user = maybeUser;\n                if (oob.email !== user.email) {\n                    updates.email = oob.email;\n                    updates.emailVerified = true;\n                }\n                break;\n            }\n            default:\n                throw new errors_1.NotImplementedError(oob.requestType);\n        }\n    }\n    else {\n        if (reqBody.idToken) {\n            ({ user, signInProvider } = parseIdToken(state, reqBody.idToken));\n            errors_1.assert(reqBody.disableUser == null, \"OPERATION_NOT_ALLOWED\");\n        }\n        else {\n            errors_1.assert(reqBody.localId, \"MISSING_LOCAL_ID\");\n            const maybeUser = state.getUserByLocalId(reqBody.localId);\n            errors_1.assert(maybeUser, \"USER_NOT_FOUND\");\n            user = maybeUser;\n        }\n        if (reqBody.email) {\n            errors_1.assert(utils_1.isValidEmailAddress(reqBody.email), \"INVALID_EMAIL\");\n            const newEmail = utils_1.canonicalizeEmailAddress(reqBody.email);\n            if (newEmail !== user.email) {\n                errors_1.assert(!state.getUserByEmail(newEmail), \"EMAIL_EXISTS\");\n                updates.email = newEmail;\n                updates.emailVerified = false;\n                isEmailUpdate = true;\n                if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.email && !user.initialEmail) {\n                    updates.initialEmail = user.email;\n                }\n            }\n        }\n        if (reqBody.password) {\n            errors_1.assert(reqBody.password.length >= PASSWORD_MIN_LENGTH, `WEAK_PASSWORD : Password should be at least ${PASSWORD_MIN_LENGTH} characters`);\n            updates.salt = \"fakeSalt\" + utils_1.randomId(20);\n            updates.passwordHash = hashPassword(reqBody.password, updates.salt);\n            updates.passwordUpdatedAt = Date.now();\n            signInProvider = state_1.PROVIDER_PASSWORD;\n        }\n        if (reqBody.password || reqBody.validSince || updates.email) {\n            updates.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n        }\n        if (reqBody.mfa) {\n            if (reqBody.mfa.enrollments && reqBody.mfa.enrollments.length > 0) {\n                updates.mfaInfo = getMfaEnrollmentsFromRequest(state, reqBody.mfa.enrollments);\n            }\n            else {\n                updates.mfaInfo = undefined;\n            }\n        }\n        const fieldsToCopy = [\n            \"displayName\",\n            \"photoUrl\",\n        ];\n        if (privileged) {\n            if (reqBody.disableUser != null) {\n                updates.disabled = reqBody.disableUser;\n            }\n            if (reqBody.phoneNumber && reqBody.phoneNumber !== user.phoneNumber) {\n                errors_1.assert(utils_1.isValidPhoneNumber(reqBody.phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n                errors_1.assert(!state.getUserByPhoneNumber(reqBody.phoneNumber), \"PHONE_NUMBER_EXISTS\");\n                updates.phoneNumber = reqBody.phoneNumber;\n            }\n            fieldsToCopy.push(\"emailVerified\", \"customAttributes\", \"createdAt\", \"lastLoginAt\", \"validSince\");\n        }\n        for (const field of fieldsToCopy) {\n            if (reqBody[field] != null) {\n                utils_1.mirrorFieldTo(updates, field, reqBody);\n            }\n        }\n        for (const attr of reqBody.deleteAttribute) {\n            switch (attr) {\n                case \"USER_ATTRIBUTE_NAME_UNSPECIFIED\":\n                    continue;\n                case \"DISPLAY_NAME\":\n                    updates.displayName = undefined;\n                    break;\n                case \"PHOTO_URL\":\n                    updates.photoUrl = undefined;\n                    break;\n                case \"PASSWORD\":\n                    updates.passwordHash = undefined;\n                    updates.salt = undefined;\n                    break;\n                case \"EMAIL\":\n                    updates.email = undefined;\n                    updates.emailVerified = undefined;\n                    updates.emailLinkSignin = undefined;\n                    break;\n            }\n        }\n        if ((_a = reqBody.deleteProvider) === null || _a === void 0 ? void 0 : _a.includes(state_1.PROVIDER_PASSWORD)) {\n            updates.email = undefined;\n            updates.emailVerified = undefined;\n            updates.emailLinkSignin = undefined;\n            updates.passwordHash = undefined;\n            updates.salt = undefined;\n        }\n        if ((_b = reqBody.deleteProvider) === null || _b === void 0 ? void 0 : _b.includes(state_1.PROVIDER_PHONE)) {\n            updates.phoneNumber = undefined;\n        }\n    }\n    user = state.updateUserByLocalId(user.localId, updates, {\n        deleteProviders: reqBody.deleteProvider,\n    });\n    if (signInProvider !== state_1.PROVIDER_ANONYMOUS && user.initialEmail && isEmailUpdate) {\n        if (!emulatorUrl) {\n            throw new Error(\"Internal assertion error: missing emulatorUrl param\");\n        }\n        sendOobForEmailReset(state, user.initialEmail, emulatorUrl);\n    }\n    return redactPasswordHash(Object.assign({ kind: \"identitytoolkit#SetAccountInfoResponse\", localId: user.localId, emailVerified: user.emailVerified, providerUserInfo: user.providerUserInfo, email: user.email, displayName: user.displayName, photoUrl: user.photoUrl, passwordHash: user.passwordHash }, (updates.validSince && signInProvider ? issueTokens(state, user, signInProvider) : {})));\n}\nexports.setAccountInfoImpl = setAccountInfoImpl;\nfunction sendOobForEmailReset(state, initialEmail, url) {\n    const oobRecord = createOobRecord(state, initialEmail, url, {\n        requestType: \"RECOVER_EMAIL\",\n        mode: \"recoverEmail\",\n    });\n    logOobMessage(oobRecord);\n}\nfunction createOobRecord(state, email, url, params) {\n    const oobRecord = state.createOob(email, params.requestType, (oobCode) => {\n        url.pathname = \"/emulator/action\";\n        url.searchParams.set(\"mode\", params.mode);\n        url.searchParams.set(\"lang\", \"en\");\n        url.searchParams.set(\"oobCode\", oobCode);\n        url.searchParams.set(\"apiKey\", \"fake-api-key\");\n        if (params.continueUrl) {\n            url.searchParams.set(\"continueUrl\", params.continueUrl);\n        }\n        if (state instanceof state_1.TenantProjectState) {\n            url.searchParams.set(\"tenantId\", state.tenantId);\n        }\n        return url.toString();\n    });\n    return oobRecord;\n}\nfunction logOobMessage(oobRecord) {\n    const oobLink = oobRecord.oobLink;\n    const email = oobRecord.email;\n    let maybeMessage;\n    switch (oobRecord.requestType) {\n        case \"EMAIL_SIGNIN\":\n            maybeMessage = `To sign in as ${email}, follow this link: ${oobLink}`;\n            break;\n        case \"PASSWORD_RESET\":\n            maybeMessage = `To reset the password for ${email}, follow this link: ${oobLink}&newPassword=NEW_PASSWORD_HERE`;\n            break;\n        case \"VERIFY_EMAIL\":\n            maybeMessage = `To verify the email address ${email}, follow this link: ${oobLink}`;\n            break;\n        case \"RECOVER_EMAIL\":\n            maybeMessage = `To reset your email address to ${email}, follow this link: ${oobLink}`;\n            break;\n    }\n    if (maybeMessage) {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", maybeMessage);\n    }\n}\nfunction signInWithCustomToken(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(reqBody.token, \"MISSING_CUSTOM_TOKEN\");\n    let payload;\n    if (reqBody.token.startsWith(\"{\")) {\n        try {\n            payload = JSON.parse(reqBody.token);\n        }\n        catch (_b) {\n            throw new errors_1.BadRequestError(\"INVALID_CUSTOM_TOKEN : ((Auth Emulator only accepts strict JSON or JWTs as fake custom tokens.))\");\n        }\n    }\n    else {\n        const decoded = jsonwebtoken_1.decode(reqBody.token, { complete: true });\n        if (state instanceof state_1.TenantProjectState) {\n            errors_1.assert((decoded === null || decoded === void 0 ? void 0 : decoded.payload.tenant_id) === state.tenantId, \"TENANT_ID_MISMATCH\");\n        }\n        errors_1.assert(decoded, \"INVALID_CUSTOM_TOKEN : Invalid assertion format\");\n        if (decoded.header.alg !== \"none\") {\n            emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed custom token. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n        }\n        errors_1.assert(decoded.payload.aud === exports.CUSTOM_TOKEN_AUDIENCE, `INVALID_CUSTOM_TOKEN : ((Invalid aud (audience): ${decoded.payload.aud} ` +\n            \"Note: Firebase ID Tokens / third-party tokens cannot be used with signInWithCustomToken.))\");\n        payload = decoded.payload;\n    }\n    const localId = (_a = coercePrimitiveToString(payload.uid)) !== null && _a !== void 0 ? _a : coercePrimitiveToString(payload.user_id);\n    errors_1.assert(localId, \"MISSING_IDENTIFIER\");\n    let extraClaims = {};\n    if (\"claims\" in payload) {\n        validateCustomClaims(payload.claims);\n        extraClaims = payload.claims;\n    }\n    let user = state.getUserByLocalId(localId);\n    const isNewUser = state.usageMode === state_1.UsageMode.PASSTHROUGH ? false : !user;\n    const updates = {\n        customAuth: true,\n        lastLoginAt: Date.now().toString(),\n        tenantId: state instanceof state_1.TenantProjectState ? state.tenantId : undefined,\n    };\n    if (user) {\n        errors_1.assert(!user.disabled, \"USER_DISABLED\");\n        user = state.updateUserByLocalId(localId, updates);\n    }\n    else {\n        user = state.createUserWithLocalId(localId, updates);\n        if (!user) {\n            throw new Error(`Internal assertion error: trying to create duplicate localId: ${localId}`);\n        }\n    }\n    return Object.assign({ kind: \"identitytoolkit#VerifyCustomTokenResponse\", isNewUser }, issueTokens(state, user, state_1.PROVIDER_CUSTOM, { extraClaims }));\n}\nfunction signInWithEmailLink(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.enableEmailLinkSignin, \"OPERATION_NOT_ALLOWED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n    errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n    const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n    errors_1.assert(reqBody.oobCode, \"MISSING_OOB_CODE\");\n    const oob = state.validateOobCode(reqBody.oobCode);\n    errors_1.assert(oob && oob.requestType === \"EMAIL_SIGNIN\", \"INVALID_OOB_CODE\");\n    errors_1.assert(email === oob.email, \"INVALID_EMAIL : The email provided does not match the sign-in email address.\");\n    state.deleteOobCode(reqBody.oobCode);\n    const updates = {\n        email,\n        emailVerified: true,\n        emailLinkSignin: true,\n    };\n    if (state instanceof state_1.TenantProjectState) {\n        updates.tenantId = state.tenantId;\n    }\n    let user = state.getUserByEmail(email);\n    const isNewUser = !user && !userFromIdToken;\n    if (!user) {\n        if (userFromIdToken) {\n            user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n        }\n        else {\n            user = state.createUser(updates);\n        }\n    }\n    else {\n        errors_1.assert(!user.disabled, \"USER_DISABLED\");\n        errors_1.assert(!userFromIdToken || userFromIdToken.localId === user.localId, \"EMAIL_EXISTS\");\n        user = state.updateUserByLocalId(user.localId, updates);\n    }\n    const response = {\n        kind: \"identitytoolkit#EmailLinkSigninResponse\",\n        email,\n        localId: user.localId,\n        isNewUser,\n    };\n    if ((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = user.mfaInfo) === null || _a === void 0 ? void 0 : _a.length)) {\n        return Object.assign(Object.assign({}, response), mfaPending(state, user, state_1.PROVIDER_PASSWORD));\n    }\n    else {\n        user = state.updateUserByLocalId(user.localId, { lastLoginAt: Date.now().toString() });\n        return Object.assign(Object.assign({}, response), issueTokens(state, user, state_1.PROVIDER_PASSWORD));\n    }\n}\nfunction signInWithIdp(state, reqBody) {\n    var _a, _b;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    if (reqBody.returnRefreshToken) {\n        throw new errors_1.NotImplementedError(\"returnRefreshToken is not implemented yet.\");\n    }\n    if (reqBody.pendingIdToken) {\n        throw new errors_1.NotImplementedError(\"pendingIdToken is not implemented yet.\");\n    }\n    const normalizedUri = getNormalizedUri(reqBody);\n    const providerId = (_a = normalizedUri.searchParams.get(\"providerId\")) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    errors_1.assert(providerId, `INVALID_CREDENTIAL_OR_PROVIDER_ID : Invalid IdP response/credential: ${normalizedUri.toString()}`);\n    const oauthIdToken = normalizedUri.searchParams.get(\"id_token\") || undefined;\n    const oauthAccessToken = normalizedUri.searchParams.get(\"access_token\") || undefined;\n    const claims = parseClaims(oauthIdToken) || parseClaims(oauthAccessToken);\n    if (!claims) {\n        if (oauthIdToken) {\n            throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${oauthIdToken} ((Auth Emulator only accepts strict JSON or JWTs as fake id_tokens.))`);\n        }\n        else if (oauthAccessToken) {\n            if (providerId === \"google.com\" || providerId === \"apple.com\") {\n                throw new errors_1.NotImplementedError(`The Auth Emulator only support sign-in with ${providerId} using id_token, not access_token. Please update your code to use id_token.`);\n            }\n            else {\n                throw new errors_1.NotImplementedError(`The Auth Emulator does not support ${providerId} sign-in with credentials.`);\n            }\n        }\n        else {\n            throw new errors_1.NotImplementedError(\"The Auth Emulator only supports sign-in with credentials (id_token required).\");\n        }\n    }\n    let { response, rawId } = fakeFetchUserInfoFromIdp(providerId, claims);\n    response.oauthAccessToken =\n        oauthAccessToken || `FirebaseAuthEmulatorFakeAccessToken_${providerId}`;\n    response.oauthIdToken = oauthIdToken;\n    const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n    const userMatchingProvider = state.getUserByProviderRawId(providerId, rawId);\n    let accountUpdates;\n    try {\n        if (userFromIdToken) {\n            errors_1.assert(!userMatchingProvider, \"FEDERATED_USER_ID_ALREADY_LINKED\");\n            ({ accountUpdates, response } = handleLinkIdp(state, response, userFromIdToken));\n        }\n        else if (state.oneAccountPerEmail) {\n            const userMatchingEmail = response.email ? state.getUserByEmail(response.email) : undefined;\n            ({ accountUpdates, response } = handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail));\n        }\n        else {\n            ({ accountUpdates, response } = handleIdpSigninEmailNotRequired(response, userMatchingProvider));\n        }\n    }\n    catch (err) {\n        if (reqBody.returnIdpCredential && err instanceof errors_1.BadRequestError) {\n            response.errorMessage = err.message;\n            return response;\n        }\n        else {\n            throw err;\n        }\n    }\n    if (response.needConfirmation) {\n        return response;\n    }\n    const providerUserInfo = {\n        providerId,\n        rawId,\n        federatedId: rawId,\n        displayName: response.displayName,\n        photoUrl: response.photoUrl,\n        email: response.email,\n        screenName: response.screenName,\n    };\n    let user;\n    if (response.isNewUser) {\n        user = state.createUser(Object.assign(Object.assign({}, accountUpdates.fields), { lastLoginAt: Date.now().toString(), providerUserInfo: [providerUserInfo], tenantId: state instanceof state_1.TenantProjectState ? state.tenantId : undefined }));\n        response.localId = user.localId;\n    }\n    else {\n        if (!response.localId) {\n            throw new Error(\"Internal assertion error: localId not set for exising user.\");\n        }\n        user = state.updateUserByLocalId(response.localId, Object.assign({}, accountUpdates.fields), {\n            upsertProviders: [providerUserInfo],\n        });\n    }\n    if (user.email === response.email) {\n        response.emailVerified = user.emailVerified;\n    }\n    if (state instanceof state_1.TenantProjectState) {\n        response.tenantId = state.tenantId;\n    }\n    if ((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.length)) {\n        return Object.assign(Object.assign({}, response), mfaPending(state, user, providerId));\n    }\n    else {\n        user = state.updateUserByLocalId(user.localId, { lastLoginAt: Date.now().toString() });\n        return Object.assign(Object.assign({}, response), issueTokens(state, user, providerId));\n    }\n}\nfunction signInWithPassword(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state.allowPasswordSignup, \"PASSWORD_LOGIN_DISABLED\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert(reqBody.email, \"MISSING_EMAIL\");\n    errors_1.assert(reqBody.password, \"MISSING_PASSWORD\");\n    if (reqBody.captchaResponse || reqBody.captchaChallenge) {\n        throw new errors_1.NotImplementedError(\"captcha unimplemented\");\n    }\n    if (reqBody.idToken || reqBody.pendingIdToken) {\n        throw new errors_1.NotImplementedError(\"idToken / pendingIdToken is no longer in use and unsupported by the Auth Emulator.\");\n    }\n    const email = utils_1.canonicalizeEmailAddress(reqBody.email);\n    let user = state.getUserByEmail(email);\n    errors_1.assert(user, \"EMAIL_NOT_FOUND\");\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    errors_1.assert(user.passwordHash && user.salt, \"INVALID_PASSWORD\");\n    errors_1.assert(user.passwordHash === hashPassword(reqBody.password, user.salt), \"INVALID_PASSWORD\");\n    const response = {\n        kind: \"identitytoolkit#VerifyPasswordResponse\",\n        registered: true,\n        localId: user.localId,\n        email,\n    };\n    if ((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = user.mfaInfo) === null || _a === void 0 ? void 0 : _a.length)) {\n        return Object.assign(Object.assign({}, response), mfaPending(state, user, state_1.PROVIDER_PASSWORD));\n    }\n    else {\n        user = state.updateUserByLocalId(user.localId, { lastLoginAt: Date.now().toString() });\n        return Object.assign(Object.assign({}, response), issueTokens(state, user, state_1.PROVIDER_PASSWORD));\n    }\n}\nfunction signInWithPhoneNumber(state, reqBody) {\n    var _a;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(state instanceof state_1.AgentProjectState, \"UNSUPPORTED_TENANT_OPERATION\");\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    let phoneNumber;\n    if (reqBody.temporaryProof) {\n        errors_1.assert(reqBody.phoneNumber, \"MISSING_PHONE_NUMBER\");\n        const proof = state.validateTemporaryProof(reqBody.temporaryProof, reqBody.phoneNumber);\n        errors_1.assert(proof, \"INVALID_TEMPORARY_PROOF\");\n        ({ phoneNumber } = proof);\n    }\n    else {\n        errors_1.assert(reqBody.sessionInfo, \"MISSING_SESSION_INFO\");\n        errors_1.assert(reqBody.code, \"MISSING_CODE\");\n        phoneNumber = verifyPhoneNumber(state, reqBody.sessionInfo, reqBody.code);\n    }\n    let user = state.getUserByPhoneNumber(phoneNumber);\n    let isNewUser = false;\n    const updates = {\n        phoneNumber,\n        lastLoginAt: Date.now().toString(),\n    };\n    const userFromIdToken = reqBody.idToken ? parseIdToken(state, reqBody.idToken).user : undefined;\n    if (!user) {\n        if (userFromIdToken) {\n            errors_1.assert(!((_a = userFromIdToken.mfaInfo) === null || _a === void 0 ? void 0 : _a.length), \"UNSUPPORTED_FIRST_FACTOR : A phone number cannot be set as a first factor on an SMS based MFA user.\");\n            user = state.updateUserByLocalId(userFromIdToken.localId, updates);\n        }\n        else {\n            isNewUser = true;\n            user = state.createUser(updates);\n        }\n    }\n    else {\n        errors_1.assert(!user.disabled, \"USER_DISABLED\");\n        if (userFromIdToken && userFromIdToken.localId !== user.localId) {\n            if (!reqBody.temporaryProof) {\n                return Object.assign({}, state.createTemporaryProof(phoneNumber));\n            }\n            throw new errors_1.BadRequestError(\"PHONE_NUMBER_EXISTS\");\n        }\n        user = state.updateUserByLocalId(user.localId, updates);\n    }\n    const tokens = issueTokens(state, user, state_1.PROVIDER_PHONE);\n    return Object.assign({ isNewUser,\n        phoneNumber, localId: user.localId }, tokens);\n}\nfunction grantToken(state, reqBody) {\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    errors_1.assert(reqBody.grantType, \"MISSING_GRANT_TYPE\");\n    errors_1.assert(reqBody.grantType === \"refresh_token\", \"INVALID_GRANT_TYPE\");\n    errors_1.assert(reqBody.refreshToken, \"MISSING_REFRESH_TOKEN\");\n    const refreshTokenRecord = state.validateRefreshToken(reqBody.refreshToken);\n    errors_1.assert(refreshTokenRecord, \"INVALID_REFRESH_TOKEN\");\n    errors_1.assert(!refreshTokenRecord.user.disabled, \"USER_DISABLED\");\n    const tokens = issueTokens(state, refreshTokenRecord.user, refreshTokenRecord.provider, {\n        extraClaims: refreshTokenRecord.extraClaims,\n        secondFactor: refreshTokenRecord.secondFactor,\n    });\n    return {\n        id_token: tokens.idToken,\n        access_token: tokens.idToken,\n        expires_in: tokens.expiresIn,\n        refresh_token: tokens.refreshToken,\n        token_type: \"Bearer\",\n        user_id: refreshTokenRecord.user.localId,\n        project_id: state.projectNumber,\n    };\n}\nfunction deleteAllAccountsInProject(state) {\n    state.deleteAllAccounts();\n    return {};\n}\nfunction getEmulatorProjectConfig(state) {\n    return {\n        signIn: {\n            allowDuplicateEmails: !state.oneAccountPerEmail,\n        },\n        usageMode: state.usageMode,\n    };\n}\nfunction updateEmulatorProjectConfig(state, reqBody) {\n    var _a;\n    const allowDuplicateEmails = (_a = reqBody.signIn) === null || _a === void 0 ? void 0 : _a.allowDuplicateEmails;\n    if (allowDuplicateEmails != null) {\n        errors_1.assert(state instanceof state_1.AgentProjectState, \"((Only top level projects can set oneAccountPerEmail.))\");\n        state.oneAccountPerEmail = !allowDuplicateEmails;\n    }\n    const usageMode = reqBody.usageMode;\n    if (usageMode != null) {\n        errors_1.assert(state instanceof state_1.AgentProjectState, \"((Only top level projects can set usageMode.))\");\n        switch (usageMode) {\n            case \"PASSTHROUGH\":\n                errors_1.assert(state.getUserCount() === 0, \"Users are present, unable to set passthrough mode\");\n                state.usageMode = state_1.UsageMode.PASSTHROUGH;\n                break;\n            case \"DEFAULT\":\n                state.usageMode = state_1.UsageMode.DEFAULT;\n                break;\n            default:\n                throw new errors_1.BadRequestError(\"Invalid usage mode provided\");\n        }\n    }\n    return getEmulatorProjectConfig(state);\n}\nfunction listOobCodesInProject(state) {\n    return {\n        oobCodes: [...state.listOobCodes()],\n    };\n}\nfunction listVerificationCodesInProject(state) {\n    return {\n        verificationCodes: [...state.listVerificationCodes()],\n    };\n}\nfunction mfaEnrollmentStart(state, reqBody) {\n    var _a, _b;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    const { user, signInProvider } = parseIdToken(state, reqBody.idToken);\n    errors_1.assert(!MFA_INELIGIBLE_PROVIDER.has(signInProvider), \"UNSUPPORTED_FIRST_FACTOR : MFA is not available for the given first factor.\");\n    errors_1.assert(user.emailVerified, \"UNVERIFIED_EMAIL : Need to verify email first before enrolling second factors.\");\n    errors_1.assert(reqBody.phoneEnrollmentInfo, \"INVALID_ARGUMENT : ((Missing phoneEnrollmentInfo.))\");\n    const phoneNumber = reqBody.phoneEnrollmentInfo.phoneNumber;\n    errors_1.assert(phoneNumber && utils_1.isValidPhoneNumber(phoneNumber), \"INVALID_PHONE_NUMBER : Invalid format.\");\n    errors_1.assert(!((_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.some((enrollment) => enrollment.unobfuscatedPhoneInfo === phoneNumber)), \"SECOND_FACTOR_EXISTS : Phone number already enrolled as second factor for this account.\");\n    const { sessionInfo, code } = state.createVerificationCode(phoneNumber);\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To enroll MFA with ${phoneNumber}, use the code ${code}.`);\n    return {\n        phoneSessionInfo: {\n            sessionInfo,\n        },\n    };\n}\nfunction mfaEnrollmentFinalize(state, reqBody) {\n    var _a, _b;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    let { user, signInProvider } = parseIdToken(state, reqBody.idToken);\n    errors_1.assert(!MFA_INELIGIBLE_PROVIDER.has(signInProvider), \"UNSUPPORTED_FIRST_FACTOR : MFA is not available for the given first factor.\");\n    errors_1.assert(reqBody.phoneVerificationInfo, \"INVALID_ARGUMENT : ((Missing phoneVerificationInfo.))\");\n    if (reqBody.phoneVerificationInfo.androidVerificationProof) {\n        throw new errors_1.NotImplementedError(\"androidVerificationProof is unsupported!\");\n    }\n    const { code, sessionInfo } = reqBody.phoneVerificationInfo;\n    errors_1.assert(code, \"MISSING_CODE\");\n    errors_1.assert(sessionInfo, \"MISSING_SESSION_INFO\");\n    const phoneNumber = verifyPhoneNumber(state, sessionInfo, code);\n    errors_1.assert(!((_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.some((enrollment) => enrollment.unobfuscatedPhoneInfo === phoneNumber)), \"SECOND_FACTOR_EXISTS : Phone number already enrolled as second factor for this account.\");\n    const existingFactors = user.mfaInfo || [];\n    const existingIds = new Set();\n    for (const { mfaEnrollmentId } of existingFactors) {\n        if (mfaEnrollmentId) {\n            existingIds.add(mfaEnrollmentId);\n        }\n    }\n    const enrollment = {\n        displayName: reqBody.displayName,\n        enrolledAt: new Date().toISOString(),\n        mfaEnrollmentId: newRandomId(28, existingIds),\n        phoneInfo: phoneNumber,\n        unobfuscatedPhoneInfo: phoneNumber,\n    };\n    user = state.updateUserByLocalId(user.localId, {\n        mfaInfo: [...existingFactors, enrollment],\n    });\n    const { idToken, refreshToken } = issueTokens(state, user, signInProvider, {\n        secondFactor: { identifier: enrollment.mfaEnrollmentId, provider: state_1.PROVIDER_PHONE },\n    });\n    return {\n        idToken,\n        refreshToken,\n    };\n}\nfunction mfaEnrollmentWithdraw(state, reqBody) {\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert(reqBody.idToken, \"MISSING_ID_TOKEN\");\n    let { user, signInProvider } = parseIdToken(state, reqBody.idToken);\n    errors_1.assert(user.mfaInfo, \"MFA_ENROLLMENT_NOT_FOUND\");\n    const updatedList = user.mfaInfo.filter((enrollment) => enrollment.mfaEnrollmentId !== reqBody.mfaEnrollmentId);\n    errors_1.assert(updatedList.length < user.mfaInfo.length, \"MFA_ENROLLMENT_NOT_FOUND\");\n    user = state.updateUserByLocalId(user.localId, { mfaInfo: updatedList });\n    return Object.assign({}, issueTokens(state, user, signInProvider));\n}\nfunction mfaSignInStart(state, reqBody) {\n    var _a, _b;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n    errors_1.assert(reqBody.mfaPendingCredential, \"MISSING_MFA_PENDING_CREDENTIAL : Request does not have MFA pending credential.\");\n    errors_1.assert(reqBody.mfaEnrollmentId, \"MISSING_MFA_ENROLLMENT_ID : No second factor identifier is provided.\");\n    const { user } = parsePendingCredential(state, reqBody.mfaPendingCredential);\n    const enrollment = (_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.find((factor) => factor.mfaEnrollmentId === reqBody.mfaEnrollmentId);\n    errors_1.assert(enrollment, \"MFA_ENROLLMENT_NOT_FOUND\");\n    const phoneNumber = enrollment.unobfuscatedPhoneInfo;\n    errors_1.assert(phoneNumber, \"INVALID_ARGUMENT : MFA provider not supported!\");\n    const { sessionInfo, code } = state.createVerificationCode(phoneNumber);\n    emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"BULLET\", `To sign in with MFA using ${phoneNumber}, use the code ${code}.`);\n    return {\n        phoneResponseInfo: {\n            sessionInfo,\n        },\n    };\n}\nfunction mfaSignInFinalize(state, reqBody) {\n    var _a, _b;\n    errors_1.assert(!state.disableAuth, \"PROJECT_DISABLED\");\n    errors_1.assert((state.mfaConfig.state === \"ENABLED\" || state.mfaConfig.state === \"MANDATORY\") && ((_a = state.mfaConfig.enabledProviders) === null || _a === void 0 ? void 0 : _a.includes(\"PHONE_SMS\")), \"OPERATION_NOT_ALLOWED : SMS based MFA not enabled.\");\n    errors_1.assert(reqBody.mfaPendingCredential, \"MISSING_CREDENTIAL : Please set MFA Pending Credential.\");\n    errors_1.assert(reqBody.phoneVerificationInfo, \"INVALID_ARGUMENT : MFA provider not supported!\");\n    if (reqBody.phoneVerificationInfo.androidVerificationProof) {\n        throw new errors_1.NotImplementedError(\"androidVerificationProof is unsupported!\");\n    }\n    const { code, sessionInfo } = reqBody.phoneVerificationInfo;\n    errors_1.assert(code, \"MISSING_CODE\");\n    errors_1.assert(sessionInfo, \"MISSING_SESSION_INFO\");\n    const phoneNumber = verifyPhoneNumber(state, sessionInfo, code);\n    let { user, signInProvider } = parsePendingCredential(state, reqBody.mfaPendingCredential);\n    const enrollment = (_b = user.mfaInfo) === null || _b === void 0 ? void 0 : _b.find((enrollment) => enrollment.unobfuscatedPhoneInfo == phoneNumber);\n    errors_1.assert(enrollment && enrollment.mfaEnrollmentId, \"MFA_ENROLLMENT_NOT_FOUND\");\n    user = state.updateUserByLocalId(user.localId, { lastLoginAt: Date.now().toString() });\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    const { idToken, refreshToken } = issueTokens(state, user, signInProvider, {\n        secondFactor: { identifier: enrollment.mfaEnrollmentId, provider: state_1.PROVIDER_PHONE },\n    });\n    return {\n        idToken,\n        refreshToken,\n    };\n}\nfunction coercePrimitiveToString(value) {\n    switch (typeof value) {\n        case \"string\":\n            return value;\n        case \"number\":\n        case \"boolean\":\n            return value.toString();\n        default:\n            return undefined;\n    }\n}\nfunction redactPasswordHash(user) {\n    return user;\n}\nfunction hashPassword(password, salt) {\n    return `fakeHash:salt=${salt}:password=${password}`;\n}\nfunction issueTokens(state, user, signInProvider, { extraClaims, secondFactor, } = {}) {\n    user = state.updateUserByLocalId(user.localId, { lastRefreshAt: new Date().toISOString() });\n    const usageMode = state.usageMode === state_1.UsageMode.PASSTHROUGH ? \"passthrough\" : undefined;\n    const tenantId = state instanceof state_1.TenantProjectState ? state.tenantId : undefined;\n    const expiresInSeconds = 60 * 60;\n    const idToken = generateJwt(user, {\n        projectId: state.projectId,\n        signInProvider,\n        expiresInSeconds,\n        extraClaims,\n        secondFactor,\n        usageMode,\n        tenantId,\n    });\n    const refreshToken = state.usageMode === state_1.UsageMode.DEFAULT\n        ? state.createRefreshTokenFor(user, signInProvider, {\n            extraClaims,\n            secondFactor,\n        })\n        : undefined;\n    return {\n        idToken,\n        refreshToken,\n        expiresIn: expiresInSeconds.toString(),\n    };\n}\nfunction parseIdToken(state, idToken) {\n    errors_1.assert(state.usageMode !== state_1.UsageMode.PASSTHROUGH, \"UNSUPPORTED_PASSTHROUGH_OPERATION\");\n    const decoded = jsonwebtoken_1.decode(idToken, { complete: true });\n    errors_1.assert(decoded, \"INVALID_ID_TOKEN\");\n    if (decoded.header.alg !== \"none\") {\n        emulatorLogger_1.EmulatorLogger.forEmulator(types_1.Emulators.AUTH).log(\"WARN\", \"Received a signed JWT. Auth Emulator does not validate JWTs and IS NOT SECURE\");\n    }\n    if (decoded.payload.firebase.tenant) {\n        errors_1.assert(state instanceof state_1.TenantProjectState, \"((Parsed token that belongs to tenant in a non-tenant project.))\");\n        errors_1.assert(decoded.payload.firebase.tenant === state.tenantId, \"TENANT_ID_MISMATCH\");\n    }\n    const user = state.getUserByLocalId(decoded.payload.user_id);\n    errors_1.assert(user, \"USER_NOT_FOUND\");\n    errors_1.assert(!user.validSince || decoded.payload.iat >= Number(user.validSince), \"TOKEN_EXPIRED\");\n    errors_1.assert(!user.disabled, \"USER_DISABLED\");\n    const signInProvider = decoded.payload.firebase.sign_in_provider;\n    return { user, signInProvider, payload: decoded.payload };\n}\nfunction generateJwt(user, { projectId, signInProvider, expiresInSeconds, extraClaims = {}, secondFactor, usageMode, tenantId, }) {\n    const identities = {};\n    if (user.email) {\n        identities[\"email\"] = [user.email];\n    }\n    if (user.providerUserInfo) {\n        for (const providerInfo of user.providerUserInfo) {\n            if (providerInfo.providerId &&\n                providerInfo.providerId !== state_1.PROVIDER_PASSWORD &&\n                providerInfo.rawId) {\n                const ids = identities[providerInfo.providerId] || [];\n                ids.push(providerInfo.rawId);\n                identities[providerInfo.providerId] = ids;\n            }\n        }\n    }\n    const customAttributes = JSON.parse(user.customAttributes || \"{}\");\n    const customPayloadFields = Object.assign(Object.assign(Object.assign({ name: user.displayName, picture: user.photoUrl }, customAttributes), extraClaims), { email: user.email, email_verified: user.emailVerified, phone_number: user.phoneNumber, provider_id: signInProvider === \"anonymous\" ? signInProvider : undefined, auth_time: utils_1.toUnixTimestamp(getAuthTime(user)), user_id: user.localId, firebase: {\n            identities,\n            sign_in_provider: signInProvider,\n            second_factor_identifier: secondFactor === null || secondFactor === void 0 ? void 0 : secondFactor.identifier,\n            sign_in_second_factor: secondFactor === null || secondFactor === void 0 ? void 0 : secondFactor.provider,\n            usage_mode: usageMode,\n            tenant: tenantId,\n        } });\n    const jwtStr = jsonwebtoken_1.sign(customPayloadFields, \"\", {\n        algorithm: \"none\",\n        expiresIn: expiresInSeconds,\n        subject: user.localId,\n        issuer: `https://securetoken.google.com/${projectId}`,\n        audience: projectId,\n    });\n    return jwtStr;\n}\nfunction getAuthTime(user) {\n    if (user.lastLoginAt != null) {\n        const millisSinceEpoch = parseInt(user.lastLoginAt, 10);\n        const authTime = new Date(millisSinceEpoch);\n        if (isNaN(authTime.getTime())) {\n            throw new Error(`Internal assertion error: invalid user.lastLoginAt = ${user.lastLoginAt}`);\n        }\n        return authTime;\n    }\n    else if (user.lastRefreshAt != null) {\n        const authTime = new Date(user.lastRefreshAt);\n        if (isNaN(authTime.getTime())) {\n            throw new Error(`Internal assertion error: invalid user.lastRefreshAt = ${user.lastRefreshAt}`);\n        }\n        return authTime;\n    }\n    else {\n        throw new Error(`Internal assertion error: Missing user.lastLoginAt and user.lastRefreshAt`);\n    }\n}\nfunction verifyPhoneNumber(state, sessionInfo, code) {\n    const verification = state.getVerificationCodeBySessionInfo(sessionInfo);\n    errors_1.assert(verification, \"INVALID_SESSION_INFO\");\n    errors_1.assert(verification.code === code, \"INVALID_CODE\");\n    state.deleteVerificationCodeBySessionInfo(sessionInfo);\n    return verification.phoneNumber;\n}\nconst CUSTOM_ATTRIBUTES_MAX_LENGTH = 1000;\nfunction validateSerializedCustomClaims(claims) {\n    errors_1.assert(claims.length <= CUSTOM_ATTRIBUTES_MAX_LENGTH, \"CLAIMS_TOO_LARGE\");\n    let parsed;\n    try {\n        parsed = JSON.parse(claims);\n    }\n    catch (_a) {\n        throw new errors_1.BadRequestError(\"INVALID_CLAIMS\");\n    }\n    validateCustomClaims(parsed);\n}\nconst FORBIDDEN_CUSTOM_CLAIMS = [\n    \"iss\",\n    \"aud\",\n    \"sub\",\n    \"iat\",\n    \"exp\",\n    \"nbf\",\n    \"jti\",\n    \"nonce\",\n    \"azp\",\n    \"acr\",\n    \"amr\",\n    \"cnf\",\n    \"auth_time\",\n    \"firebase\",\n    \"at_hash\",\n    \"c_hash\",\n];\nfunction validateCustomClaims(claims) {\n    errors_1.assert(typeof claims === \"object\" && claims != null && !Array.isArray(claims), \"INVALID_CLAIMS\");\n    for (const reservedField of FORBIDDEN_CUSTOM_CLAIMS) {\n        errors_1.assert(!(reservedField in claims), `FORBIDDEN_CLAIM : ${reservedField}`);\n    }\n}\nfunction newRandomId(length, existingIds) {\n    for (let i = 0; i < 10; i++) {\n        const id = utils_1.randomId(length);\n        if (!(existingIds === null || existingIds === void 0 ? void 0 : existingIds.has(id))) {\n            return id;\n        }\n    }\n    throw new errors_1.InternalError(\"INTERNAL_ERROR : Failed to generate a random ID after 10 attempts\", \"INTERNAL\");\n}\nfunction getMfaEnrollmentsFromRequest(state, request, options) {\n    const enrollments = [];\n    const phoneNumbers = new Set();\n    const enrollmentIds = new Set();\n    for (const enrollment of request) {\n        errors_1.assert(enrollment.phoneInfo && utils_1.isValidPhoneNumber(enrollment.phoneInfo), \"INVALID_MFA_PHONE_NUMBER : Invalid format.\");\n        if (!phoneNumbers.has(enrollment.phoneInfo)) {\n            const mfaEnrollmentId = (options === null || options === void 0 ? void 0 : options.generateEnrollmentIds) ? newRandomId(28, enrollmentIds)\n                : enrollment.mfaEnrollmentId;\n            errors_1.assert(mfaEnrollmentId, \"INVALID_MFA_ENROLLMENT_ID : mfaEnrollmentId must be defined.\");\n            errors_1.assert(!enrollmentIds.has(mfaEnrollmentId), \"DUPLICATE_MFA_ENROLLMENT_ID\");\n            enrollments.push(Object.assign(Object.assign({}, enrollment), { mfaEnrollmentId, unobfuscatedPhoneInfo: enrollment.phoneInfo }));\n            phoneNumbers.add(enrollment.phoneInfo);\n            enrollmentIds.add(mfaEnrollmentId);\n        }\n    }\n    return state.validateMfaEnrollments(enrollments);\n}\nfunction getNormalizedUri(reqBody) {\n    errors_1.assert(reqBody.requestUri, \"MISSING_REQUEST_URI\");\n    const normalizedUri = utils_1.parseAbsoluteUri(reqBody.requestUri);\n    errors_1.assert(normalizedUri, \"INVALID_REQUEST_URI\");\n    if (reqBody.postBody) {\n        const postBodyParams = new url_1.URLSearchParams(reqBody.postBody);\n        for (const key of postBodyParams.keys()) {\n            normalizedUri.searchParams.set(key, postBodyParams.get(key));\n        }\n    }\n    const fragment = normalizedUri.hash.replace(/^#/, \"\");\n    if (fragment) {\n        const fragmentParams = new url_1.URLSearchParams(fragment);\n        for (const key of fragmentParams.keys()) {\n            normalizedUri.searchParams.set(key, fragmentParams.get(key));\n        }\n        normalizedUri.hash = \"\";\n    }\n    return normalizedUri;\n}\nfunction parseClaims(idTokenOrJsonClaims) {\n    if (!idTokenOrJsonClaims) {\n        return undefined;\n    }\n    let claims;\n    if (idTokenOrJsonClaims.startsWith(\"{\")) {\n        try {\n            claims = JSON.parse(idTokenOrJsonClaims);\n        }\n        catch (_a) {\n            throw new errors_1.BadRequestError(`INVALID_IDP_RESPONSE : Unable to parse id_token: ${idTokenOrJsonClaims} ((Auth Emulator failed to parse fake id_token as strict JSON.))`);\n        }\n    }\n    else {\n        const decoded = jsonwebtoken_1.decode(idTokenOrJsonClaims, { json: true });\n        if (!decoded) {\n            return undefined;\n        }\n        claims = decoded;\n    }\n    errors_1.assert(claims.sub, 'INVALID_IDP_RESPONSE : Invalid Idp Response: id_token missing required fields. ((Missing \"sub\" field. This field is required and must be a unique identifier.))');\n    errors_1.assert(typeof claims.sub === \"string\", 'INVALID_IDP_RESPONSE : ((The \"sub\" field must be a string.))');\n    return claims;\n}\nfunction fakeFetchUserInfoFromIdp(providerId, claims) {\n    const rawId = claims.sub;\n    const email = claims.email ? utils_1.canonicalizeEmailAddress(claims.email) : undefined;\n    const emailVerified = !!claims.email_verified;\n    const displayName = claims.name;\n    const photoUrl = claims.picture;\n    const response = {\n        kind: \"identitytoolkit#VerifyAssertionResponse\",\n        context: \"\",\n        providerId,\n        displayName,\n        fullName: displayName,\n        screenName: claims.screen_name,\n        email,\n        emailVerified,\n        photoUrl,\n    };\n    let federatedId;\n    switch (providerId) {\n        case \"google.com\": {\n            federatedId = `https://accounts.google.com/${rawId}`;\n            let granted_scopes = \"openid https://www.googleapis.com/auth/userinfo.profile\";\n            if (email) {\n                granted_scopes += \" https://www.googleapis.com/auth/userinfo.email\";\n            }\n            response.firstName = claims.given_name;\n            response.lastName = claims.family_name;\n            response.rawUserInfo = JSON.stringify({\n                granted_scopes,\n                id: rawId,\n                name: displayName,\n                given_name: claims.given_name,\n                family_name: claims.family_name,\n                verified_email: emailVerified,\n                locale: \"en\",\n                email,\n                picture: photoUrl,\n            });\n            break;\n        }\n        default:\n            federatedId = rawId;\n            response.rawUserInfo = JSON.stringify(claims);\n            break;\n    }\n    response.federatedId = federatedId;\n    return { response, rawId };\n}\nfunction handleLinkIdp(state, response, userFromIdToken) {\n    if (state.oneAccountPerEmail && response.email) {\n        const userMatchingEmail = state.getUserByEmail(response.email);\n        errors_1.assert(!userMatchingEmail || userMatchingEmail.localId === userFromIdToken.localId, \"EMAIL_EXISTS\");\n    }\n    response.localId = userFromIdToken.localId;\n    const fields = {};\n    if (state.oneAccountPerEmail && response.email && !userFromIdToken.email) {\n        fields.email = response.email;\n        fields.emailVerified = response.emailVerified;\n    }\n    if (response.email &&\n        response.emailVerified &&\n        (fields.email || userFromIdToken.email) === response.email) {\n        fields.emailVerified = true;\n    }\n    return { accountUpdates: { fields }, response };\n}\nfunction handleIdpSigninEmailNotRequired(response, userMatchingProvider) {\n    if (userMatchingProvider) {\n        return {\n            response: Object.assign(Object.assign({}, response), { localId: userMatchingProvider.localId }),\n            accountUpdates: {},\n        };\n    }\n    else {\n        return handleIdpSignUp(response, { emailRequired: false });\n    }\n}\nfunction handleIdpSigninEmailRequired(response, rawId, userMatchingProvider, userMatchingEmail) {\n    var _a, _b, _c;\n    if (userMatchingProvider) {\n        return {\n            response: Object.assign(Object.assign({}, response), { localId: userMatchingProvider.localId }),\n            accountUpdates: {},\n        };\n    }\n    else if (userMatchingEmail) {\n        if (response.emailVerified) {\n            if ((_a = userMatchingEmail.providerUserInfo) === null || _a === void 0 ? void 0 : _a.some((info) => info.providerId === response.providerId && info.rawId !== rawId)) {\n                response.emailRecycled = true;\n            }\n            response.localId = userMatchingEmail.localId;\n            const accountUpdates = {\n                fields: {},\n            };\n            if (!userMatchingEmail.emailVerified) {\n                accountUpdates.fields.passwordHash = undefined;\n                accountUpdates.fields.phoneNumber = undefined;\n                accountUpdates.fields.validSince = utils_1.toUnixTimestamp(new Date()).toString();\n                accountUpdates.deleteProviders = (_b = userMatchingEmail.providerUserInfo) === null || _b === void 0 ? void 0 : _b.map((info) => info.providerId);\n            }\n            accountUpdates.fields.dateOfBirth = response.dateOfBirth;\n            accountUpdates.fields.displayName = response.displayName;\n            accountUpdates.fields.language = response.language;\n            accountUpdates.fields.photoUrl = response.photoUrl;\n            accountUpdates.fields.screenName = response.screenName;\n            accountUpdates.fields.emailVerified = true;\n            return { response, accountUpdates };\n        }\n        else {\n            response.needConfirmation = true;\n            response.localId = userMatchingEmail.localId;\n            response.verifiedProvider = (_c = userMatchingEmail.providerUserInfo) === null || _c === void 0 ? void 0 : _c.map((info) => info.providerId).filter((id) => id !== state_1.PROVIDER_PASSWORD && id !== state_1.PROVIDER_PHONE);\n            return { response, accountUpdates: {} };\n        }\n    }\n    else {\n        return handleIdpSignUp(response, { emailRequired: true });\n    }\n}\nfunction handleIdpSignUp(response, options) {\n    const accountUpdates = {\n        fields: {\n            dateOfBirth: response.dateOfBirth,\n            displayName: response.displayName,\n            language: response.language,\n            photoUrl: response.photoUrl,\n            screenName: response.screenName,\n        },\n    };\n    if (options.emailRequired && response.email) {\n        accountUpdates.fields.email = response.email;\n        accountUpdates.fields.emailVerified = response.emailVerified;\n    }\n    return {\n        response: Object.assign(Object.assign({}, response), { isNewUser: true }),\n        accountUpdates,\n    };\n}\nfunction mfaPending(state, user, signInProvider) {\n    if (!user.mfaInfo) {\n        throw new Error(\"Internal assertion error: mfaPending called on user without MFA.\");\n    }\n    const pendingCredentialPayload = {\n        _AuthEmulatorMfaPendingCredential: \"DO NOT MODIFY\",\n        localId: user.localId,\n        signInProvider,\n        projectId: state.projectId,\n    };\n    if (state instanceof state_1.TenantProjectState) {\n        pendingCredentialPayload.tenantId = state.tenantId;\n    }\n    const mfaPendingCredential = Buffer.from(JSON.stringify(pendingCredentialPayload), \"utf8\").toString(\"base64\");\n    return { mfaPendingCredential, mfaInfo: user.mfaInfo.map(redactMfaInfo) };\n}\nfunction redactMfaInfo(mfaInfo) {\n    return {\n        displayName: mfaInfo.displayName,\n        enrolledAt: mfaInfo.enrolledAt,\n        mfaEnrollmentId: mfaInfo.mfaEnrollmentId,\n        phoneInfo: mfaInfo.unobfuscatedPhoneInfo\n            ? obfuscatePhoneNumber(mfaInfo.unobfuscatedPhoneInfo)\n            : undefined,\n    };\n}\nfunction obfuscatePhoneNumber(phoneNumber) {\n    const split = phoneNumber.split(\"\");\n    let digitsEncountered = 0;\n    for (let i = split.length - 1; i >= 0; i--) {\n        if (/[0-9]/.test(split[i])) {\n            digitsEncountered++;\n            if (digitsEncountered > 4) {\n                split[i] = \"*\";\n            }\n        }\n    }\n    return split.join(\"\");\n}\nfunction parsePendingCredential(state, pendingCredential) {\n    let pendingCredentialPayload;\n    try {\n        const json = Buffer.from(pendingCredential, \"base64\").toString(\"utf8\");\n        pendingCredentialPayload = JSON.parse(json);\n    }\n    catch (_a) {\n        errors_1.assert(false, \"((Invalid phoneVerificationInfo.mfaPendingCredential.))\");\n    }\n    errors_1.assert(pendingCredentialPayload._AuthEmulatorMfaPendingCredential, \"((Invalid phoneVerificationInfo.mfaPendingCredential.))\");\n    errors_1.assert(pendingCredentialPayload.projectId === state.projectId, \"INVALID_PROJECT_ID : Project ID does not match MFA pending credential.\");\n    if (state instanceof state_1.TenantProjectState) {\n        errors_1.assert(pendingCredentialPayload.tenantId === state.tenantId, \"INVALID_PROJECT_ID : Project ID does not match MFA pending credential.\");\n    }\n    const { localId, signInProvider } = pendingCredentialPayload;\n    const user = state.getUserByLocalId(localId);\n    errors_1.assert(user, \"((User in pendingCredentialPayload does not exist.))\");\n    return { user, signInProvider };\n}\nfunction createTenant(state, reqBody) {\n    var _a, _b, _c, _d, _e;\n    if (!(state instanceof state_1.AgentProjectState)) {\n        throw new errors_1.InternalError(\"INTERNAL_ERROR: Can only create tenant in agent project\", \"INTERNAL\");\n    }\n    const mfaConfig = (_a = reqBody.mfaConfig) !== null && _a !== void 0 ? _a : {};\n    if (!(\"state\" in mfaConfig)) {\n        mfaConfig.state = \"DISABLED\";\n    }\n    if (!(\"enabledProviders\" in mfaConfig)) {\n        mfaConfig.enabledProviders = [];\n    }\n    const tenant = {\n        displayName: reqBody.displayName,\n        allowPasswordSignup: (_b = reqBody.allowPasswordSignup) !== null && _b !== void 0 ? _b : false,\n        enableEmailLinkSignin: (_c = reqBody.enableEmailLinkSignin) !== null && _c !== void 0 ? _c : false,\n        enableAnonymousUser: (_d = reqBody.enableAnonymousUser) !== null && _d !== void 0 ? _d : false,\n        disableAuth: (_e = reqBody.disableAuth) !== null && _e !== void 0 ? _e : false,\n        mfaConfig: mfaConfig,\n        tenantId: \"\",\n    };\n    return state.createTenant(tenant);\n}\nfunction listTenants(state, reqBody, ctx) {\n    errors_1.assert(state instanceof state_1.AgentProjectState, \"((Can only list tenants in agent project.))\");\n    const pageSize = Math.min(Math.floor(ctx.params.query.pageSize) || 20, 1000);\n    const tenants = state.listTenants(ctx.params.query.pageToken);\n    let nextPageToken = undefined;\n    if (pageSize > 0 && tenants.length >= pageSize) {\n        tenants.length = pageSize;\n        nextPageToken = tenants[tenants.length - 1].tenantId;\n    }\n    return {\n        nextPageToken,\n        tenants,\n    };\n}\nfunction deleteTenant(state, reqBody, ctx) {\n    errors_1.assert(state instanceof state_1.TenantProjectState, \"((Can only delete tenant on tenant projects.))\");\n    state.delete();\n    return {};\n}\nfunction getTenant(state, reqBody, ctx) {\n    errors_1.assert(state instanceof state_1.TenantProjectState, \"((Can only get tenant on tenant projects.))\");\n    return state.tenantConfig;\n}\nfunction updateTenant(state, reqBody, ctx) {\n    errors_1.assert(state instanceof state_1.TenantProjectState, \"((Can only update tenant on tenant projects.))\");\n    return state.updateTenant(reqBody, ctx.params.query.updateMask);\n}\n"]},"metadata":{},"sourceType":"script"}