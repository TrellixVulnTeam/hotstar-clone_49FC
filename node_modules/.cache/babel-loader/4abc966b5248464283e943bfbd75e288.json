{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.partition = exports.assertExhaustive = exports.zipIn = exports.zip = exports.reduceFlat = exports.flatten = exports.flattenArray = exports.flattenObject = void 0;\n\nfunction* flattenObject(obj) {\n  function* helper(path, obj) {\n    for (const [k, v] of Object.entries(obj)) {\n      if (typeof v !== \"object\" || v === null) {\n        yield [[...path, k].join(\".\"), v];\n      } else {\n        yield* helper([...path, k], v);\n      }\n    }\n  }\n\n  yield* helper([], obj);\n}\n\nexports.flattenObject = flattenObject;\n\nfunction* flattenArray(arr) {\n  for (const val of arr) {\n    if (Array.isArray(val)) {\n      yield* flattenArray(val);\n    } else {\n      yield val;\n    }\n  }\n}\n\nexports.flattenArray = flattenArray;\n\nfunction flatten(objOrArr) {\n  if (Array.isArray(objOrArr)) {\n    return flattenArray(objOrArr);\n  } else {\n    return flattenObject(objOrArr);\n  }\n}\n\nexports.flatten = flatten;\n\nfunction reduceFlat(accum, next) {\n  return [...(accum || []), ...flatten([next])];\n}\n\nexports.reduceFlat = reduceFlat;\n\nfunction* zip(left, right) {\n  if (left.length != right.length) {\n    throw new Error(\"Cannot zip between two lists of differen lengths\");\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    yield [left[i], right[i]];\n  }\n}\n\nexports.zip = zip;\n\nexports.zipIn = other => (elem, ndx) => {\n  return [elem, other[ndx]];\n};\n\nfunction assertExhaustive(val) {\n  throw new Error(`Never has a value (${val}). This should be impossible`);\n}\n\nexports.assertExhaustive = assertExhaustive;\n\nfunction partition(arr, callbackFn) {\n  return arr.reduce((acc, elem) => {\n    acc[callbackFn(elem) ? 0 : 1].push(elem);\n    return acc;\n  }, [[], []]);\n}\n\nexports.partition = partition;","map":{"version":3,"sources":["C:/Users/Sharik/Desktop/Projects/ReactProject/my-first-app/node_modules/firebase-tools/lib/functional.js"],"names":["Object","defineProperty","exports","value","partition","assertExhaustive","zipIn","zip","reduceFlat","flatten","flattenArray","flattenObject","obj","helper","path","k","v","entries","join","arr","val","Array","isArray","objOrArr","accum","next","left","right","length","Error","i","other","elem","ndx","callbackFn","reduce","acc","push"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.partition = exports.assertExhaustive = exports.zipIn = exports.zip = exports.reduceFlat = exports.flatten = exports.flattenArray = exports.flattenObject = void 0;\nfunction* flattenObject(obj) {\n    function* helper(path, obj) {\n        for (const [k, v] of Object.entries(obj)) {\n            if (typeof v !== \"object\" || v === null) {\n                yield [[...path, k].join(\".\"), v];\n            }\n            else {\n                yield* helper([...path, k], v);\n            }\n        }\n    }\n    yield* helper([], obj);\n}\nexports.flattenObject = flattenObject;\nfunction* flattenArray(arr) {\n    for (const val of arr) {\n        if (Array.isArray(val)) {\n            yield* flattenArray(val);\n        }\n        else {\n            yield val;\n        }\n    }\n}\nexports.flattenArray = flattenArray;\nfunction flatten(objOrArr) {\n    if (Array.isArray(objOrArr)) {\n        return flattenArray(objOrArr);\n    }\n    else {\n        return flattenObject(objOrArr);\n    }\n}\nexports.flatten = flatten;\nfunction reduceFlat(accum, next) {\n    return [...(accum || []), ...flatten([next])];\n}\nexports.reduceFlat = reduceFlat;\nfunction* zip(left, right) {\n    if (left.length != right.length) {\n        throw new Error(\"Cannot zip between two lists of differen lengths\");\n    }\n    for (let i = 0; i < left.length; i++) {\n        yield [left[i], right[i]];\n    }\n}\nexports.zip = zip;\nexports.zipIn = (other) => (elem, ndx) => {\n    return [elem, other[ndx]];\n};\nfunction assertExhaustive(val) {\n    throw new Error(`Never has a value (${val}). This should be impossible`);\n}\nexports.assertExhaustive = assertExhaustive;\nfunction partition(arr, callbackFn) {\n    return arr.reduce((acc, elem) => {\n        acc[callbackFn(elem) ? 0 : 1].push(elem);\n        return acc;\n    }, [[], []]);\n}\nexports.partition = partition;\n"]},"metadata":{},"sourceType":"script"}